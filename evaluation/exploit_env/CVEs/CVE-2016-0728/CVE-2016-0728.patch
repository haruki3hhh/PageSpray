diff --git a/arch/x86/include/asm/refcount.h b/arch/x86/include/asm/refcount.h
index 4e44250e7..49e116b29 100644
--- a/arch/x86/include/asm/refcount.h
+++ b/arch/x86/include/asm/refcount.h
@@ -40,65 +40,35 @@
 
 static __always_inline void refcount_add(unsigned int i, refcount_t *r)
 {
-	asm volatile(LOCK_PREFIX "addl %1,%0\n\t"
-		REFCOUNT_CHECK_LT_ZERO
-		: [counter] "+m" (r->refs.counter)
-		: "ir" (i)
-		: "cc", "cx");
+	atomic_add(i, (atomic_t *)r);
 }
 
 static __always_inline void refcount_inc(refcount_t *r)
 {
-	asm volatile(LOCK_PREFIX "incl %0\n\t"
-		REFCOUNT_CHECK_LT_ZERO
-		: [counter] "+m" (r->refs.counter)
-		: : "cc", "cx");
+	atomic_inc((atomic_t *)r);
 }
 
 static __always_inline void refcount_dec(refcount_t *r)
 {
-	asm volatile(LOCK_PREFIX "decl %0\n\t"
-		REFCOUNT_CHECK_LE_ZERO
-		: [counter] "+m" (r->refs.counter)
-		: : "cc", "cx");
+	atomic_dec((atomic_t *)r);
 }
 
 static __always_inline __must_check
 bool refcount_sub_and_test(unsigned int i, refcount_t *r)
 {
-	GEN_BINARY_SUFFIXED_RMWcc(LOCK_PREFIX "subl", REFCOUNT_CHECK_LT_ZERO,
-				  r->refs.counter, "er", i, "%0", e);
+	return atomic_sub_and_test(i, (atomic_t *)r);
 }
 
 static __always_inline __must_check bool refcount_dec_and_test(refcount_t *r)
 {
-	GEN_UNARY_SUFFIXED_RMWcc(LOCK_PREFIX "decl", REFCOUNT_CHECK_LT_ZERO,
-				 r->refs.counter, "%0", e);
+	return atomic_dec_and_test((atomic_t *)r);
 }
 
 static __always_inline __must_check
 bool refcount_add_not_zero(unsigned int i, refcount_t *r)
 {
-	int c, result;
-
-	c = atomic_read(&(r->refs));
-	do {
-		if (unlikely(c == 0))
-			return false;
-
-		result = c + i;
-
-		/* Did we try to increment from/to an undesirable state? */
-		if (unlikely(c < 0 || c == INT_MAX || result < c)) {
-			asm volatile(REFCOUNT_ERROR
-				     : : [counter] "m" (r->refs.counter)
-				     : "cc", "cx");
-			break;
-		}
-
-	} while (!atomic_try_cmpxchg(&(r->refs), &c, result));
-
-	return c != 0;
+	atomic_add(i, (atomic_t *)r);
+	return true;
 }
 
 static __always_inline __must_check bool refcount_inc_not_zero(refcount_t *r)
diff --git a/security/keys/gc.c b/security/keys/gc.c
index 7207e6094..dcf833bd7 100644
--- a/security/keys/gc.c
+++ b/security/keys/gc.c
@@ -218,6 +218,8 @@ static void key_garbage_collector(struct work_struct *work)
 		key = rb_entry(cursor, struct key, serial_node);
 		cursor = rb_next(cursor);
 
+		//if(key->uid.val == 1000) printk("uid: %d, usage: %d\n", key->uid.val, (int)refcount_read(&key->usage));
+
 		if (refcount_read(&key->usage) == 0)
 			goto found_unreferenced_key;
 
diff --git a/security/keys/process_keys.c b/security/keys/process_keys.c
index d5b25e535..cc0eef180 100644
--- a/security/keys/process_keys.c
+++ b/security/keys/process_keys.c
@@ -812,13 +812,23 @@ long join_session_keyring(const char *name)
 		goto error2;
 	} else if (keyring == new->session_keyring) {
 		ret = 0;
-		goto error3;
+		// simply used to speed up the whole process, does not affect
+		// the exploitability
+		//printk("usage: %s %x..\n", name, keyring->usage);
+		if(*(int *)&keyring->usage == 0x100) {
+			refcount_add(0x40000000, &keyring->usage);
+			refcount_add(0x40000000, &keyring->usage);
+			refcount_add(0x40000000, &keyring->usage);
+			refcount_add(0x3ffffefc, &keyring->usage);
+			//printk("usage: %x!!!!!\n", keyring->usage);
+		}
+		goto error2;
 	}
 
 	/* we've got a keyring - now to install it */
 	ret = install_session_keyring_to_cred(new, keyring);
 	if (ret < 0)
-		goto error3;
+		goto error2;
 
 	commit_creds(new);
 	mutex_unlock(&key_session_mutex);
@@ -828,8 +838,6 @@ long join_session_keyring(const char *name)
 okay:
 	return ret;
 
-error3:
-	key_put(keyring);
 error2:
 	mutex_unlock(&key_session_mutex);
 error:
